<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LCP1106题解</title>
      <link href="/2021/10/29/LCP1106%E9%A2%98%E8%A7%A3/"/>
      <url>/2021/10/29/LCP1106%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1>解析布尔表达式</h1><p><strong>题目：</strong></p><p>给你一个以字符串形式表述的 布尔表达式（boolean） expression，返回该式的运算结果。</p><p>有效的表达式需遵循以下约定：</p><ul><li>“t”，运算结果为 True</li><li>“f”，运算结果为 False</li><li>“!(expr)”，运算过程为对内部表达式 expr 进行逻辑 非的运算（NOT）</li><li>“&amp;(expr1,expr2,…)”，运算过程为对 2 个或以上内部表达式 expr1, expr2, … 进行逻辑 与的运算（AND）</li><li>“|(expr1,expr2,…)”，运算过程为对 2 个或以上内部表达式 expr1, expr2, … 进行逻辑 或的运算（OR）</li></ul><p><strong>思路：</strong></p><p>本题类似于四则运算，所以可以考虑使用 Dijkstra 双栈算法，使用双栈算法实现简单运算的代码可以参考 <a href="https://blog.csdn.net/ZJ_DE/article/details/79670208?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163541645416780366591760%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163541645416780366591760&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-79670208.pc_search_result_control_group&amp;utm_term=%E5%8F%8C%E6%A0%88%E7%AE%97%E6%B3%95&amp;spm=1018.2226.3001.4187">Dijkstra双栈算法</a>。</p><p>在本题当中，我们需要遍历表达式，</p><ul><li>遇到操作符入栈</li><li>遇到左括号入栈</li><li>遇到操作数入栈</li><li>遇到右括号弹出操作符，再依次弹出操作数直到遇到左括号，计算结果并入栈</li></ul><p>遍历完成后操作数栈栈顶元素即为结果。</p><p><strong>代码实现如下：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">parseBoolExpr</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; opr = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Character&gt; ope = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> flag;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expression.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> s = expression.charAt(i);</span><br><span class="line">            <span class="keyword">switch</span> (s) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;!&#x27;</span>:</span><br><span class="line">                    opr.push(s);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;,&#x27;</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                    <span class="keyword">char</span> op = opr.pop();</span><br><span class="line">                    <span class="keyword">char</span> c;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:</span><br><span class="line">                            <span class="keyword">while</span>((c=ope.pop()) != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (c == <span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">                                    flag = <span class="number">1</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">                                ope.push(<span class="string">&#x27;t&#x27;</span>);</span><br><span class="line">                            <span class="keyword">else</span> ope.push(<span class="string">&#x27;f&#x27;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">                            <span class="keyword">while</span>((c=ope.pop()) != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (c == <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">                                    flag = <span class="number">1</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">                                ope.push(<span class="string">&#x27;f&#x27;</span>);</span><br><span class="line">                            <span class="keyword">else</span> ope.push(<span class="string">&#x27;t&#x27;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;!&#x27;</span>:</span><br><span class="line">                            <span class="keyword">while</span>((c=ope.pop()) != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (c == <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">                                    flag = <span class="number">1</span>;</span><br><span class="line">                                <span class="keyword">else</span> flag = <span class="number">0</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (flag == <span class="number">1</span>) ope.push(<span class="string">&#x27;t&#x27;</span>);</span><br><span class="line">                            <span class="keyword">else</span> ope.push(<span class="string">&#x27;f&#x27;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            System.out.println(<span class="string">&quot;表达式错误，结果无效！&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    ope.push(s);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ope.pop();</span><br><span class="line">        <span class="keyword">return</span> ope.pop() == <span class="string">&#x27;t&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> Dijkstra 双栈算法 </tag>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript异步与Promise</title>
      <link href="/2021/10/23/Javascript%E5%BC%82%E6%AD%A5%E4%B8%8EPromise/"/>
      <url>/2021/10/23/Javascript%E5%BC%82%E6%AD%A5%E4%B8%8EPromise/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1>JavaScript异步与Promise</h1><h2 id="Promise解决的问题">Promise解决的问题</h2><p>当一个异步任务的执行需要依赖另一个异步任务的结果时，我们一般会将两个异步任务进行嵌套，这种情况发生多次时，就形成了所谓的“回调地狱”。当代码逻辑稍微复杂一些时，程序就会变得难以维护。下面就是一个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funA</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(() = &gt; &#123;</span><br><span class="line">callback()</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funC</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;C&quot;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(() = &gt; &#123;</span><br><span class="line">callback()</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funD</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funE</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;E&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funF</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;F&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funA(() = &gt; &#123;</span><br><span class="line">funB()</span><br><span class="line">funC(() = &gt; &#123;</span><br><span class="line">funD()</span><br><span class="line">&#125;)</span><br><span class="line">funE()</span><br><span class="line">&#125;)</span><br><span class="line">funF()</span><br></pre></td></tr></table></figure><h2 id="什么是Promise">什么是Promise</h2><blockquote>    我走到快餐店的柜台前，点了一个起士汉堡。并交了1.47美元的现金。通过点餐和付款，我为得到一个 值（起士汉堡）制造了一个请求。我发起了一个事务。<br>    但是通常来说，起士汉堡不会立即到我手中。收银员交给一些东西代替我的起士汉堡：一个带有点餐排队号的收据。这个点餐号是一个“我欠你”的许诺（Promise），它保证我最终会得到我的起士汉堡。<br>    于是我就拿着我的收据和点餐号。我知道它代表我的 未来的起士汉堡，所以我无需再担心它——除了挨饿！<br>    在我等待的时候，我可以做其他的事情，比如给我的朋友发微信说，“嘿，一块儿吃午餐吗？我要吃起士汉堡”。<br>    我已经在用我的 未来的起士汉堡 进行推理了，即便它还没有到我手中。我的大脑可以这么做是因为它将点餐号作为起士汉堡的占位符号。这个占位符号实质上使这个值 与时间无关。它是一个 未来的值。<br>    最终，我听到，“113号！”。于是我愉快地拿着收据走回柜台前。我把收据递给收银员，拿回我的起士汉堡。 换句话说，一旦我的 未来的值 准备好，我就用我的许诺值换回值本身。<br>    但还有另外一种可能的输出。它们叫我的号，但当我去取起士汉堡时，收银员遗憾地告诉我，“对不起，看起来我们的起士汉堡卖光了。”把这种场景下顾客有多沮丧放在一边，我们可以看到 未来的值 的一个重要性质：它们既可以表示成功也可以表示失败。<br>    每次我点起士汉堡时，我都知道我要么最终得到一个起士汉堡，要么得到起士汉堡卖光的坏消息，并且不得不考虑中午吃点儿别的东西。<br>    我由等待汉堡变成了等到或者等不到，这个过程不可逆。</blockquote><p>《<strong>异步与性能</strong>》第三章中的这么个场景很形象地介绍了promise，上面的等待汉堡和得到汉堡，汉堡卖光了，得不到汉堡，分别对应promise的三种状态 <strong>pending: 进行中，既不是成功，也不是失败状态。 fulfilled: 意味着操作成功完成。 rejected: 意味着操作失败。</strong></p><p><strong>语法</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;...&#125; ); <span class="comment">//reject参数 可不选</span></span><br></pre></td></tr></table></figure><p><strong>参数 executor</strong></p><p>executor是带有 resolve 和 reject 两个参数的函数 。Promise构造函数执行时立即调用executor 函数， resolve 和 reject 两个函数作为参数传递给executor（executor 函数在Promise构造函数返回新建对象前被调用）。resolve 和 reject 函数被调用时，分别将promise的状态改为fulfilled（完成）或rejected（失败）。executor 内部通常会执行一些异步操作，一旦完成，可以调用resolve函数来将promise状态改成fulfilled，或者在发生错误时将它的状态改为rejected。</p><p>如果在executor函数中抛出一个错误，那么该promise 状态为rejected。executor函数的返回值被忽略。</p><p>新建一个Promise的实例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject) = &gt; &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(() = &gt; &#123;</span><br><span class="line"><span class="keyword">let</span> random = <span class="built_in">Math</span>.random()</span><br><span class="line"><span class="keyword">if</span> (random &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">resolve(<span class="string">`resolve$ &#123;random&#125;`</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">resolve(<span class="string">`reject$ &#123;random&#125;`</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Promise的构造函数接收一个函数作为参数，该函数接受两个额外的函数，resolve和reject，这两个函数分别代表将当前Promise置为fulfilled(已成功)和rejected(已失败)两个状态。Promise正是通过这两个状态来控制异步操作的结果。接下来我们将讨论Promise的用法，实际上Promise上的实例promise是一个对象，不是一个函数。在声明的时候，<strong>Promise传递的参数函数会立即执行，因此Promise使用的正确姿势是在其外层再包裹一层函数</strong>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> random = <span class="built_in">Math</span>.random()</span><br><span class="line"><span class="keyword">if</span> (random &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">resolve(<span class="string">`resolve:<span class="subst">$&#123;random&#125;</span>`</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">reject(<span class="string">`reject:<span class="subst">$&#123;random&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run()</span><br></pre></td></tr></table></figure><p>每个Promise的实例对象，都有一个then的方法，这个方法就是用来处理之前各种异步逻辑的结果。</p><p>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p><h3 id="Promise-then">Promise.then()</h3><p><strong>语法</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p.then(onFulfilled,onRejected)</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">　　<span class="comment">// fulfillment</span></span><br><span class="line">　&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">　　 <span class="comment">// rejection</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><blockquote>    onFulfilled<br>    当Promise变成接受状态（fulfillment）时，该参数作为回调函数被调用。该函数有一个参数，即接受的最终结果（the fulfillment value）。如果传入的 onFulfilled 参数类型不是函数，则会在内部被替换为(x) => x ，即原样返回 promise 最终结果的函数。<br>    onRejected　(可选)<br>    当Promise变成拒绝状态（rejection ）时，该参数作为回调函数被调用。该函数有一个参数,，即拒绝的原因（the rejection reason）。<br></blockquote><p><strong>返回值</strong></p><p>then()方法返回一个Promise，而它的行为与then中的回调函数返回值有关，示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">reject</span> =&gt;</span>&#123;</span><br><span class="line">    reject(<span class="string">&quot;出错了!&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 第一个 then()</span></span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`res1:<span class="subst">$&#123;res&#125;</span>`</span>) <span class="comment">// 这里不执行</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;,<span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`err1:<span class="subst">$&#123;err&#125;</span>`</span>) <span class="comment">// err1:出错了!</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 第二个 then()</span></span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`res2:<span class="subst">$&#123;res&#125;</span>`</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;这是一个错误提示!&quot;</span></span><br><span class="line">&#125;,<span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`err2:<span class="subst">$&#123;err&#125;</span>`</span>) <span class="comment">// 这里不执行</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 第三个 then()</span></span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`res3:<span class="subst">$&#123;res&#125;</span>`</span>) <span class="comment">// 这里不执行</span></span><br><span class="line">&#125;,<span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`err3:<span class="subst">$&#123;err&#125;</span>`</span>) <span class="comment">// 这是一个错误提示!</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 第四个 then()</span></span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`res4:<span class="subst">$&#123;res&#125;</span>`</span>) <span class="comment">// undefined</span></span><br><span class="line">&#125;,<span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`err4:<span class="subst">$&#123;err&#125;</span>`</span>) <span class="comment">// 这里不执行</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 第五个 then()</span></span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`res5:<span class="subst">$&#123;res&#125;</span>`</span>) <span class="comment">// undefined</span></span><br><span class="line">&#125;,<span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`err5:<span class="subst">$&#123;err&#125;</span>`</span>) <span class="comment">// 这里不执行</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote>如果then中的回调函数返回一个值，那么then返回的Promise将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。<br>　　如果then中的回调函数抛出一个错误，那么then返回的Promise将会成为拒绝状态，并且将抛出的错误作为拒绝状态的回调函数的参数值。<br>　　如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。<br>　　如果then中的回调函数返回一个已经是拒绝状态的Promise，那么then返回的Promise也会成为拒绝状态，并且将那个Promise的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。<br>　　如果then中的回调函数返回一个未定状态（pending）的Promise，那么then返回Promise的状态也是未定的，并且它的终态与那个Promise的终态相同；同时，它变为终态时调用的回调函数参数与那个Promise变为终态时的回调函数的参数是相同的。<br></blockquote><p>请读者仔细分析上述示例代码。</p><h3 id="Promise-catch">Promise.catch()</h3><p>catch()方法就类似于then(null, rejection)或then(undefined, rejection)，catch用于捕获错误，它的参数也就是then的第二个参数。</p><h2 id="ES-6对于Promise的扩展">ES 6对于Promise的扩展</h2><h3 id="Promise-all">Promise.all()</h3><p>all()方法是用于将多个Promise实例，包装成一个新的Promise实例。all方法接收的参数是一个可迭代对象，比如：Array、String等，也可以是一个数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="built_in">Promise</span>.all([promise1, promise2, promise3])</span><br><span class="line">        .then(<span class="function"><span class="params">res</span>=&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;Promise.all成功了!&#x27;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;Promise.all出错了!&#x27;</span>);</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>上例中，使用数组作为all()方法的参数，数组中的每一项都返回一个Promise实例。如果三个promise实例都返回fulfillment状态，那么all()方法返回fulfillment状态，返回一个由三个promise实例的返回值组成的数组。它们在数组中的顺序与执行顺序无关，与它们作为参数排列的顺序有关。</p><p>如果有一个返回失败（reject），那么all()方法返回失败（reject）的状态，此时第一个被reject的实例的返回值，会传递给promise的回调函数。</p><p><strong>Promise.all()只关心集体的执行结果。</strong></p><h3 id="Promise-race">Promise.race()</h3><p>Promise中的竞态，用法和all()方法类似，对应参数也与all()方法一样是一个可迭代对象，race()方法返回一个Promise，谁执行的快就返回谁的执行结果，无论结果是成功还是失败。</p><p>即使已经完成，进程也不会立即停止，还是会继续执行。</p><h3 id="Promise-finally">Promise.finally()</h3><p>finally() 方法返回一个Promise，在promise执行结束时，无论结果是成功或者是失败，在执行then()和catch()后，都会执行finally指定的回调函数,该方法是 ES 9 引入标准的。</p><h2 id="generator函数">generator函数</h2><p>在异步编程中，还有一种常用的解决方案，它就是Generator生成器函数。顾名思义，它是一个生成器，它也是一个状态机，内部拥有值及相关的状态，生成器返回一个迭代器Iterator对象，我们可以通过这个迭代器，手动地遍历相关的值、状态，保证正确的执行顺序。</p><h3 id="generator基本用法">generator基本用法</h3><p>generator函数与普通的函数相比，有两个特征：</p><ol><li>function关键字与函数名之间又一个*号</li><li>函数体内使用yield表达式来遍历状态</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="string">&#x27;one&#x27;</span></span><br><span class="line"><span class="keyword">yield</span> <span class="string">&#x27;two&#x27;</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;three&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fun1 = generator()</span><br><span class="line"><span class="built_in">console</span>.log(fun1)</span><br><span class="line"><span class="built_in">console</span>.log(fun1.next())  </span><br><span class="line"><span class="built_in">console</span>.log(fun1.next())</span><br><span class="line"><span class="built_in">console</span>.log(fun1.next())</span><br><span class="line"><span class="built_in">console</span>.log(fun1.next())</span><br></pre></td></tr></table></figure><p>上述代码定义了一个generator生成器函数，调用之后返回了一个迭代器对象，调用方法next后，函数内执行第一条yield语句，输出当前的状态done（生成器函数是否已经执行完毕并返回），以及返回值value（一般为yield关键字后面的运算结果）。</p><p>每调用一次next就执行一条yield语句，并在此处暂停。</p><p>当在生成器函数中显式 return 时，会导致生成器立即变为完成状态，就退出了生成器函数，后续如果还有yield操作就不再执行了，即调用 next() 方法返回的对象的 done 为 true。如果 return 后面跟了一个值，那么这个值会作为当前调用 next() 方法返回的 value 值。</p><h3 id="yield和yield">yield和yield*</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="string">&#x27;one&#x27;</span></span><br><span class="line">      <span class="keyword">yield</span>* generator2(<span class="number">13</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;three&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator2</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">yield</span> num</span><br><span class="line">      <span class="keyword">yield</span> num + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> Ljj = generator()</span><br><span class="line"><span class="built_in">console</span>.log(Ljj.next())</span><br><span class="line"><span class="built_in">console</span>.log(Ljj.next())</span><br><span class="line"><span class="built_in">console</span>.log(Ljj.next())</span><br><span class="line"><span class="built_in">console</span>.log(Ljj.next())</span><br></pre></td></tr></table></figure><p>当这个迭代器的 next() 方法被调用时，其内的语句会执行到第一个（后续）出现yield的位置为止，yield 是你给什么它提取什么，但是 yield* 会继续向下请求，将执行权移交给另一个生成器函数，当前生成器暂停执行，直到提取完为止。</p><p><em><em>注意：yield和yield</em> 只能在generator函数内部使用，一般的函数内使用会报错</em>*</p><h3 id="next-中传参">next()中传参</h3><p>调用 next()方法时，如果传入了参数，那么这个参数会作为上一条执行的 yield 语句的返回值.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    x = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    y = <span class="keyword">yield</span> x * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> y * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Ljj = generator();</span><br><span class="line"><span class="built_in">console</span>.log(Ljj.next());</span><br><span class="line"><span class="built_in">console</span>.log(Ljj.next());</span><br><span class="line"><span class="built_in">console</span>.log(Ljj.next(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(Ljj.next());</span><br></pre></td></tr></table></figure><p>第一次调用next之后返回值x为1，但在第二次调用next的时候x其实是undefined的，因为generator不会自动保存相应变量值，我们需要手动的指定，这时y值为NaN，在第三次调用next的时候执行到yield 3 * y，通过传参将上次yield返回值y设为2，得到结果6</p><h3 id="for…of循环代替next">for…of循环代替next()</h3><p>除了使用.next()方法遍历迭代器对象外，通过ES 6提供的新循环方式for…of也可遍历，但与next不同的是，它会忽略return返回的值。</p><h2 id="async函数">async函数</h2><p>async作为一个关键字放到函数前面，用于表示函数是一个异步函数，异步函数不会阻塞后面代码的执行。async函数返回的是一个promise对象，如果要获取promise的返回值，还要使用then方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">testAsync().then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;<span class="built_in">console</span>.log(res)&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;我在后面,我执行了!&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="await关键字">await关键字</h3><p>await关键字和yield关键字一样，不能够单独使用。await关键字需要使用在async函数中，它的后面可以跟任何表达式，它的作用是阻塞主函数的执行，直到后面的表达式返回结果。</p><p>原文链接：<a href="https://blog.csdn.net/qq_42911663/article/details/85790181">https://blog.csdn.net/qq_42911663/article/details/85790181</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Promise </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解Javascript回调函数</title>
      <link href="/2021/10/23/%E7%90%86%E8%A7%A3Javascript%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
      <url>/2021/10/23/%E7%90%86%E8%A7%A3Javascript%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1>理解JavaScript回调函数</h1><p>在JavaScript中，function 是内置的类对象，也就是说它是一种类型的对象，可以和其他类的对象一样用于内置对象的管理。因为function 实际上是一种对象，它可以存储在变量中，通过参数传递给（另一个）函数，在函数内部创建，从函数中返回结果值。因为function是内置对象，我们可以将它作为参数传递给另一个函数，延迟到函数中执行，甚至执行后将它返回。</p><p><strong>回调函数</strong>来自一种著名的编程范式——<strong>函数式编程</strong>，在基本层面上，函数式编程指定的了函数的参数。</p><h2 id="什么是回调或高级函数？">什么是回调或高级函数？</h2><p>回调函数指的是需要在将来不确定的某一时刻异步调用的函数。回调函数被认为是一种高级函数，一种被作为参数传递给另一个函数(在这称作&quot;otherFunction&quot;)的高级函数，回调函数会在otherFunction内被调用(或执行)。回调函数的本质是一种模式(一种解决常见问题的模式)，因此回调函数也被称为回调模式。下面是一个回调函数的例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> friends = [<span class="string">&quot;Mike&quot;</span>, <span class="string">&quot;Stacy&quot;</span>, <span class="string">&quot;Andy&quot;</span>, <span class="string">&quot;Rick&quot;</span>];</span><br><span class="line"> </span><br><span class="line">friends.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">eachName, index</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(index + <span class="number">1</span> + <span class="string">&quot;. &quot;</span> + eachName);</span><br><span class="line">    <span class="comment">// 1. Mike, 2. Stacy, 3. Andy, 4. Rick</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="回调函数是如何实现的？">回调函数是如何实现的？</h2><p>我们可以像使用变量一样使用函数，作为另一个函数的参数，在另一个函数中作为返回结果，在另一个函数中调用它。当我们作为参数传递一个回调函数给另一个函数时，我们只传递了这个函数的定义，并没有在参数中执行它。</p><p>当包含(调用)函数拥有了在参数中定义的回调函数后，它可以在任何时候调用(也就是回调)它。</p><p>回调函数是闭包的<br>当作为参数传递一个回调函数给另一个函数时，回调函数将在包含函数函数体内的某个位置被执行，就像回调函数在包含函数的函数体内定义一样。这意味着回调函数是闭包的，闭包函数可以访问包含函数的作用域，所以，回调函数可以访问包含函数的变量，甚至是全局变量。</p><h2 id="实现回调函数的基本原则">实现回调函数的基本原则</h2><p><strong>使用命名函数或匿名函数作为回调</strong></p><p>在前面的的例子中，我们在包含函数的参数中定义匿名函数，这是使用回调函数的通用形式之一，另一个经常被使用的形式是定义一个带名称的函数，并将函数名作为参数传递给另一个函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> allUserData = [];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logStuff</span> (<span class="params">userData</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> userData === <span class="string">&quot;string&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(userData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="keyword">typeof</span> userData === <span class="string">&quot;object&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">in</span> userData) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(item + <span class="string">&quot;: &quot;</span> + userData[item]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInput</span> (<span class="params">options, callback</span>) </span>&#123;</span><br><span class="line">    allUserData.push (options);</span><br><span class="line">    callback (options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getInput (&#123;<span class="attr">name</span>:<span class="string">&quot;Rich&quot;</span>, <span class="attr">speciality</span>:<span class="string">&quot;JavaScript&quot;</span>&#125;, logStuff);</span><br><span class="line"><span class="comment">//  name: Rich</span></span><br><span class="line"><span class="comment">// speciality: JavaScript</span></span><br></pre></td></tr></table></figure><p><strong>传递参数给回调函数</strong></p><p>因为回调函数在执行的时候就和一般函数一样，我们可以传递参数给它。可以将包含函数的任何属性(或全局的属性)作为参数传递回调函数。在上一个例子中，我们将包含函数的options作为参数传递给回调函数。</p><p><strong>在执行之前确保回调是一个函数</strong></p><p>在调用之前，确保通过参数传递进来的回调是一个需要的函数通常是明智的。如果没有检查传递进来的是否是一个函数，或者是否通过参数传递进来了，那么代码可能会导致运行时错误。</p><p><strong>使用含有this对象的回调函数的问题</strong></p><p>当回调函数是一个含有this对象的方法时，我们必须修改执行回调函数的方法以保护this对象的内容。否则this对象将会指向全局的window对象(如果回调函数传递给了全局函数)，或指向包含函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> clientData = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">094545</span>,</span><br><span class="line">    <span class="attr">fullName</span>: <span class="string">&quot;Not Set&quot;</span>,</span><br><span class="line">    <span class="attr">setUserName</span>: <span class="function"><span class="keyword">function</span> (<span class="params">firstName, lastName</span>)  </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.fullName = firstName + <span class="string">&quot; &quot;</span> + lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInput</span>(<span class="params">firstName, lastName, callback</span>)  </span>&#123;</span><br><span class="line">    callback (firstName, lastName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserInput (<span class="string">&quot;Barack&quot;</span>, <span class="string">&quot;Obama&quot;</span>, clientData.setUserName);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log (clientData.fullName);<span class="comment">// Not Set</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log (<span class="built_in">window</span>.fullName); <span class="comment">// Barack Obama</span></span><br></pre></td></tr></table></figure><p>在上述代码中，当clientData.setUserName被执行时，this.fullName不会设置clientData 对象中的属性fullName，而是设置window 对象中的fullName，因为getUserInput是一个全局函数。出现这种现象是因为在全局函数中this对象指向了window对象。</p><p><strong>使用Call或Apply函数保护this对象</strong></p><p>我们可以通过使用 Call 或 Apply函数来解决前面示例中的问题。JavaScript中的每一个函数都有两个方法:Call和Apply。这些方法可以被用来在函数内部设置this对象的内容，并内容传递给函数参数指向的对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInput</span>(<span class="params">firstName, lastName, callback, callbackObj</span>)  </span>&#123;</span><br><span class="line">    callback.apply (callbackObj, [firstName, lastName]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserInput (<span class="string">&quot;Barack&quot;</span>, <span class="string">&quot;Obama&quot;</span>, clientData.setUserName, clientData);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log (clientData.fullName); <span class="comment">// Barack Obama</span></span><br></pre></td></tr></table></figure><p>参考文章链接：<a href="https://blog.csdn.net/luoweifu/article/details/41466537?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163481784316780262573369%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163481784316780262573369&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-41466537.pc_search_result_control_group&amp;utm_term=javascript+%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/luoweifu/article/details/41466537?ops_request_misc=%7B%22request%5Fid%22%3A%22163481784316780262573369%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=163481784316780262573369&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-41466537.pc_search_result_control_group&amp;utm_term=javascript+回调函数&amp;spm=1018.2226.3001.4187</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 回调函数 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络期末复习</title>
      <link href="/2021/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E6%94%BB%E7%95%A5/"/>
      <url>/2021/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E6%94%BB%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1>计算机网络复习攻略</h1><h2 id="一、名词解释">一、名词解释</h2><ul><li><p>IP：Internet Protocol 网际互连协议</p></li><li><p>IPCP：IP Control Protocol IP控制协议</p></li><li><p>ARP：Address Resolution Protocol 地址解析协议</p></li><li><p>RARP：Reverse Address Resolution Protocol 逆地址解析协议</p></li><li><p>HTTP：Hypertext Transfer Protocol 超文本传输协议</p></li><li><p>ICMP：Internet Control Message Protocol 网际控制报文协议</p></li><li><p>DNS：Domain Name System 域名系统</p></li><li><p>PPP：Point-to-Point Protocol 点对点协议</p></li><li><p>TCP：Transmission Control Protocol 传输控制协议</p></li><li><p>UDP：User Datagram Protocol 用户数据报协议</p></li><li><p>WWW：World Wide Web 万维网</p></li><li><p>IMAP：Internet Message Access Protocol 网际报文存取协议</p></li><li><p>RIP：Routing Information Protocol 路由信息协议</p></li><li><p>FTP：File Transfer Protocol 文件传输协议</p></li><li><p>TFTP：Trivial File Transfer Protocol 简单文件传输协议</p></li><li><p>DHCP：Dynamic Host Configuration Protocol 动态主机配置协议</p></li><li><p>EGP：External Gateway Protocol 外部网关协议</p></li><li><p>IGP：Interior Gateway Protocol 内部网关协议</p></li><li><p>LAN：Local Area Network 局域网</p></li><li><p>MAN：Metropolitan Area Network</p></li><li><p>NCP：Network Control Protocol 网络控制协议</p></li><li><p>P2P：Peer-to-Peer 对等方式</p></li><li><p>PAN：Personal Area Network 个人区域网</p></li></ul><h2 id="二、简答题">二、简答题</h2><h3 id="1-DNS-工作原理">1. DNS 工作原理</h3><p>DNS：（Domain Name System,域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，<br>而不去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫域名解析。</p><h4 id="1-DNS-服务">1) DNS 服务</h4><p>将IP地址与形象易记的域名一一对应起来，使用户在访问服务器或网站时不使用IP地址，而使用简单易记的域名，通过DNS服务器将域名自动解析成IP地址并定位服务器。</p><hr><h4 id="2-正向解析和反向解析">2) 正向解析和反向解析</h4><p>当DNS 客户机向DNS 服务器提交域名查询IP 地址，或DNS 服务器向另一台DNS 服务器提交域名查询IP 地址，DNS 服务器作出响应的过程称为正向解析。反之，当DNS 客户机向DNS 服务器提交IP 地址查询域名，或DNS 服务器向另一台DNS 服务器提交IP 地址查询域名，DNS 服务器作出响应的过程成为反向解析。</p><h4 id="3-递归查询与迭代查询">3) 递归查询与迭代查询</h4><p>递归查询：收到客户机查询请求后，DNS 服务器在自己的缓存或区域数据库中查找，如找到则返回结果；如找不到，DNS 服务器指向转发器定义的其他DNS 服务器进行查询，最终将查询结果返回给客户机。</p><p>迭代查询：将请求发给根域DNS 服务器，依序从根域查到顶级域，从顶级域查到二级域，再从二级域查到三级域，经此类推直至找到要解析的地址或域名，然后向客户机所在网络的DNS 服务器发出应答信息，DNS 服务器收到信息后转发给客户机。如果最终都没有找到所需的信息，则向客户机返回错误信息。</p><h3 id="2-ARP">2. ARP</h3><h4 id="1-ARP简介">1) ARP简介</h4><p>地址解析协议（Address Resolution Protocol），其基本功能为透过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。它是IPv4中网络层必不可少的协议，不过在IPv6中已不再适用，并被邻居发现协议（NDP）所替代。</p><h4 id="2-IP-地址与MAC-地址">2) IP 地址与MAC 地址</h4><p>MAC 地址是数据链路层和物理层使用的地址，而IP 地址是网络层和以上各层使用的地址，是一种逻辑地址（IP 地址是使用软件实现的）。在发送数据时，数据从高层到低层，然后才到通信链路上传输。使用IP 地址的IP 数据报一旦交给了数据链路层就被封装成了MAC 帧。**MAC 帧在传送时使用的原地址和目的地址都是硬件地址。连接在通信链路上的设备（主机或路由器）在接受MAC 帧时，根据的是MAC 帧首部的硬件地址。**在数据链路层看不到隐藏在MAC 帧中的IP 地址，只有剥去MAC 帧的首部和尾部后把MAC 层的数据交给网络层后，网络层才能在IP数据报的首部中找到源IP 地址和目的IP 地址。</p><h4 id="3-基本功能">3) 基本功能</h4><p>在以太网协议中规定，同一局域网中的一台主机要和另一台主机进行直接通信，必须要知道目标主机的MAC地址。而在TCP/IP协议中，网络层和传输层只关心目标主机的IP地址。这就导致在以太网中使用IP协议时，数据链路层的以太网协议接到上层IP协议提供的数据中，只包含目的主机的IP地址。于是需要一种方法，根据目的主机的IP地址，获得其MAC地址。这就是ARP协议要做的事情。所谓地址解析（address resolution）就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。</p><p><strong>注意：在点对点链路中不使用ARP，实际上在点对点网络中也不使用MAC地址，因为在此类网络中分别已经获取了对端的IP地址。</strong></p><h4 id="4-工作原理">4) 工作原理</h4><p>在TCP/IP 协议中，A 给B 发送IP 包时，在A 不知道B 的MAC 地址的情况下，A 就广播一个ARP 请求包，请求包中填有B 的IP ，以太网中的所有计算机都会接收这个请求，而正常情况下只有B 会给出ARP 应答包，包中就填充上了B 的MAC 地址，并回复给A 。A 得到ARP 应答后，将B 的MAC 地址放入本机缓存，便于下次使用。</p><p>（1）<strong>ARP进程在本局域网上广播发送一个ARP请求分组</strong></p><p>（2）<strong>本局域网上所有的主机上运行的ARP进程都收到此ARP请求分组。</strong></p><p>（3）<strong>主机B在ARP分组中见到自己的IP地址就向A发送ARP响应分组，并写入自己的硬件地址，相应分组是普通的单播。</strong></p><p>（4）<strong>主机A收到主机B的ARP响应分组后，就在其ARP高速缓存中写入主机B的IP地址到硬件地址的映射。</strong></p><p>（5）<strong>另外，当发送主机和目的主机不在同一个局域网中时，即便知道目的主机的MAC地址，两者也不能直接通信，必须经过路由转发才可以。所以此时，发送主机通过ARP协议获得的将不是目的主机的真实MAC地址，而是一台可以通往局域网外的路由器的MAC地址。于是此后发送主机发往目的主机的所有帧，都将发往该路由器，通过它向外发送。这种情况称为委托ARP或ARP代理（ARP Proxy）。</strong></p><h3 id="3-常用传输媒体">3. 常用传输媒体</h3><h4 id="1-常用传输媒体有哪些">1) 常用传输媒体有哪些</h4><ul><li>**双绞线 ：**屏蔽双绞线 STP（Shielded Twisted Pair） 无屏蔽双绞线 UTP（Unshielded Twisted Pair）</li><li>**同轴电缆：**50W 同轴电缆 75W 同轴电缆</li><li>**光缆：**单模光纤 多模光纤</li><li>**无线传输：**短波通信 / 微波 / 卫星通信</li></ul><h4 id="2）简介">2）简介</h4><ul><li>双绞线分屏蔽双绞线和无屏蔽双绞线。由两根相互绝缘的导线组成。可以传输模拟信号，也可以传输数字信号，有效带宽达250kHz，通常距离一般为几道十几公里。导线越粗其通信距离越远。在数字传输时，若传输速率为每秒几兆比特，则传输距离可达几公里。一般用作电话线传输声音信号。虽然双绞线容易受到外部高频电磁波的干扰，误码率高，但因为其价格便宜，且安装方便，既适于点到点连接，又可用于多点连接，故仍被广泛应用。</li><li>同轴电缆分基带同轴电缆和宽带同轴电缆，其结构是在一个包有绝缘的实心导线外，再套上一层外面也有一层绝缘的空心圆形导线。由于其高带宽（高达300~400Hz）、低误码率、性能价格比高，所以用作LAN中。同轴电缆的最大传输距离随电缆型号和传输信号的不同而不同，由于易受低频干扰，在使用时多将信号调制在高频载波上。</li><li>光导纤维以光纤维载体，利用光的全反向原理传播光信号。其优点是直径小、质量轻：传播频带款、通信容量大：抗雷电和电磁干扰性能好，五串音干扰、保密性好、误码率低。但光电接口的价格较昂贵。光纤被广泛用于电信系统铺设主干线。</li><li>无线电微波通信分为地面微波接力通信和卫星通信。其主要优点是频率高、频带范围宽、通信信道的容量大；信号所受工业干扰较小、传播质量高、通信比较稳定；不受地理环境的影响，建设投资少、见效快。缺点是地面微波接力通信在空间是直线传播，传输距离受到限制，一般只有50km，隐蔽性和保密性较差；卫星通信虽然通信距离远且通信费用与通信距离无关，但传播时延较大，技术较复杂，价格较贵。</li></ul><h4 id="3）特点">3）特点</h4><ul><li>双绞线：<ul><li>可以传输模拟信号、数字信号</li><li>双绞线容易受到外部高频电子波的干扰，误码率高</li><li>价格便宜、安装方便、既适用点到点连接又可用于多点连接</li></ul></li><li>同轴电缆：<ul><li>在局域网发展的初期曾广泛使用同轴电缆作为传输媒体</li><li>具有很好的抗干扰特性</li></ul></li><li>光导纤维：<ul><li>传输损耗小，可实现长距离传输</li><li>体积小，质量轻</li><li>传输速率高，通信容量大</li><li>抗雷电和电磁干扰性能好，保密性好，误码率低</li></ul></li><li>无线电微波通信<ul><li>通信容量大，传输频率宽</li><li>受外界干扰小，传输质量高</li><li>初建成本低，易于跨越山区、江河</li></ul></li></ul><h3 id="4-信道复用">4. 信道复用</h3><h4 id="1）为什么要使用信道复用技术">1）为什么要使用信道复用技术</h4><p>信道复用的目的是让不同的计算机连接到相同的信道上，以共享信道资源。在一条传输介质上传输多个信号，提高线路的利用率，降低网络的成本。采用信道复用是为了提高系统容量和系统的效率。</p><h4 id="2）信道复用技术都有哪些">2）信道复用技术都有哪些</h4><p>常用的信道复用技术有四种：频分复用、时分复用、波分复用和码分复用。</p><p><strong>频分复用</strong>（Frequency Division Multiplexing，FDM）就是将用于传输信道的总带宽划分成若干个子频带（或称子信道），每一个子信道传输一路信号。频分复用要求总频率宽度大于各个子信道频率之和，同时为了保证各子信道中所传递的信号互不干扰，应在各子信道之间设立隔离带，这样就保证了各路信号互不干扰（条件之一）。频分复用技术的特点是所有子信道传输的信号以并行的方式工作，每一路信号传输时可不考虑传输时延，因而频分复用技术取得了非常广泛的应用。频分复用除传统意义上的频分复用（FDM）外还有一种是正交频分复用（OFDM）。</p><p><strong>时分复用</strong>（Time Division Multiplexing，TDM）就是将提供给整个信道传输信息的时间划分成若干时间片（简称时隙），并将这些时隙分配给每一个信号源使用，每一路信号在自己的时隙内单独占用信道进行数据传输。时分复用技术的特点是时隙事先规划分配好且固定不变，所以有时候也叫同步时分复用。其优点是时隙分配固定，便于调节控制，适于数字信息的传输；缺点是当某信号源没有数据传输时，它所对应的信道会出现空闲而其他繁忙的信道无法占用这个空闲的信道，因此会降低线路的利用率。</p><p><strong>频分复用</strong>（Wavelength Division Multiplexing， WDM）在光通信领域人们习惯按波长而不是按频率来命名。因此所谓的波分复用其本质上也是频分复用而已。WDM是在一根光纤上承载多个波长（信道）系统将一根光纤转换为多条“虚拟”光纤，每条“虚拟”光纤独立工作在不同波长上，这样极大地提高了光纤的传输容量。</p><p><strong>码分复用</strong>（Code Division Multiplexing，CDM）是靠不同的编码来区分各路原始信号的一种复用方式，主要和各种多址技术结合产生了各种接入技术，包括无线和有线接入。</p><h3 id="5-数据链路层三大任务">5. 数据链路层三大任务</h3><h4 id="1）封装成帧">1）封装成帧</h4><p>数据链路层的发送方应当让接收方的数据链路层知道，所发送的帧是从什么地方开始到什么地方结束。</p><ul><li>就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。</li><li>接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。</li><li>分组交换的一个重要概念：就是所有因特网上传送的数据都是以分组（即IP 数据报）为传送单位。</li><li>网络层的IP 数据报传送到数据链路层就成为帧的数据部分。在帧的数据部分前面和后面分别添加上首部和尾部，就构成了一个完整的帧。</li><li>帧长等于数据部分长度加上帧首部和帧尾部的长度，而首部和尾部的一个重要作用就是进行帧定界（即确定帧的界限）。</li><li>首部和尾部还包含许多必要的控制信息，在发送帧时，是从帧首部开始发送。</li><li>各种数据链路层协议都要对帧首部和帧尾部的格式有明确的规定。</li><li>为了提高帧的传输效率，应当使帧的数据部分长度尽可能大于首部和尾部的长度。但是，每一种链路层协议都规定了帧的数据部分长度上限——最大传送单元MTU（Maximum Transfer Unit）。</li><li>当数据是由可打印的ASCII码组成的文本文件时，帧定界可以使用特殊的帧定界符。</li><li>控制字符SOH（Start Of Header）放在一帧的最前面，表示帧的首部开始。另一个控制字符EOT（End Of Transmission）表示帧的结束。他们的十六进制编码分别是01（二进制是00000001）和04（二进制是00000100）。</li><li>当数据在传输中出现差错时，帧定界符的作用更加明显。假定发送端在尚未发完一个帧时突然出现故障，中断了发送。但随后很快又恢复正常，于是重新从头开始发送刚才未发送完的帧。<strong>由于使用了帧定界符，在接收端就知道前面收到的数据时个不完整的帧(只有首部SOH，没有传输结束符EOT)，必须丢弃。而后面收到的数据有明显的帧定界符(SOH和EOT)，因此这是一个完整的帧，应当收下。</strong></li></ul><h4 id="2）透明传输">2）透明传输</h4><p>数据链路层传送的比特组合必须是不受限制的。</p><ul><li>由于帧的开始和结束的标记是使用专门指明的控制字符，因此，所传输的数据中任何8bit 的组合一定不允许和用作帧定界的控制字符的比特编码一样，否则就会出现帧定界的错误。</li><li>当传送的帧使用文本文件组成的帧时（文本文件中的字符是从键盘上输入的），其数据部分显然不会出现像SOH或EOT这样的帧定界控制字符。可见不管从键盘上输入什么字符都可以放在这样的帧中传输过去，因此这样的传输就是透明传输。</li><li>当数据部分是非ASCII码的文本文件时（如二进制代码的计算机程序或图像等），如果数据中心的某个字符的二进制代码恰好和SOH或EOT这种控制字符一样，数据链路层就会错误地找到帧的边界，把部分帧收下（误以为是完整的帧），而把剩下的那部分数据丢弃（这部分找不到帧定界控制字符SOH）。这样的帧的传输显然就不是透明传输。</li><li>为了解决透明传输的问题，就必须设法使数据中可能出现的控制字符在接收端不被解析为控制字符。</li><li>解决方法是发送端的数据链路层在数据中出现控制字符的前面加上一个转义字符“ESC”（其十六进制编码是1B）。而在接收端的数据链路层在数据送往网络层之前删除这个插入的转义字符。这种方法称为字节填充（byte stuffing）或字符填充（character stuffing）。如果转义字符也出现在数据当中，那么解决方法仍然是在转义字符的前面插入一个转义字符。因此，当接收端收到连续的两个转义字符时就删除其中的前面一个。</li></ul><h4 id="3）差错检测">3）差错检测</h4><p>数据链路层必须有差错检测功能。</p><ul><li>传输差错：可分为两大类，位错和帧错。位错就是最基本的比特差错，帧错就是收到的帧并没有出现错误，但却出现了帧丢失、帧重复或帧失序。</li><li>比特差错：就是比特在传输过程中可能会产生差错，即1变成0，0变成1。</li><li>误码率BER（Bit Error Rate）：就是在一段时间内，传输错误的比特占所传输比特总数的比率。误码率与信噪比有很大的关系，如果提高信噪比，就可以使误码率减小。</li><li>实际的通信链路并非理想的，不可能使误码率下降到零。</li><li>为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种检测措施。</li><li>目前在数据链路层广泛使用了循环冗余校验CRC（Cycle Redundancy Check）的检测技术。</li><li><strong>在数据链路层使用CRC检验，能够实现无比特差错的传输，但这还不是可靠传输。</strong></li></ul><p><strong>因特网广泛使用的数据链路层协议都不适用确认和重传机制，即不要求数据链路层向上层提供可靠传输的服务(因为这要付出的代价太高，不合算)。如果在数据链路层传输数据时除了差错并且需要进行改正，那么改正差错的任务就由上层协议(如，运输层TCP协议)来完成。实验证明，这样可以提高通信效率。</strong></p><h3 id="6-网络层提供的两种服务">6. 网络层提供的两种服务</h3><h4 id="1）虚电路服务">1）虚电路服务</h4><ul><li>传统电信网提供的主要业务是提供电话服务。电信网使用昂贵的程控交换机，用面向连接的通信方式，使电信网络能够向用户(实际上就是电话机)提供可靠传输的服务。</li><li>当两个计算机进行通信的步骤：<ul><li>(1)应当先建立连接(但在分组交换中是建立一条虚电路VC(Virtual Circuit))，以保证通信双方所需的一切网络资源。</li><li>(2)然后双方就沿着已建立的虚电路发送分组。</li><li>(3)这样的分组的首部就不需要填写完整的目的主机地址，而只需填写这条虚电路的编号(一个不大的整数)，因而减少了分组的开销。</li><li>(4)如果这种通信方式再使用可靠传输的网络协议，就可使所发送的分组无差错按序地到达终点，当然也不丢失、不重复。</li><li>(5)在通信结束后，要释放建立的虚电路。</li></ul></li></ul><h4 id="2）数据报服务">2）数据报服务</h4><ul><li>因特网在设计上就采用了和电信网完全不同的思路。</li><li>由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉(与电信网的交换机相比较)。</li><li>因特网的设计思路：<ul><li>(1)网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络在发送分组时不需要先建立连接。每个分组(也就是IP数据报)独立发送，与其前后的分组无关(不进行编号)。</li><li>(2)网络层不提供服务质量的承诺。也就是说所传送的分组，可能出错、丢失、重复或失序，当然也不保证分组交付的时限。</li></ul></li><li><strong>这种设计思路的好处：</strong><ul><li>(1)网络的造价大大降低。</li><li>(2)运行方式灵活。</li><li>(3)能够适应多种应用。</li></ul></li></ul><h3 id="7-TCP-IP">7. TCP/IP</h3><p>从字面意义上，TCP/IP 是指TCP 和IP 两种协议，然而很多情况下它只是利用IP 进行通信时所必须用到的协议群的统称。</p><h4 id="1）计算机网络体系结构分层">1）计算机网络体系结构分层</h4><table><thead><tr><th style="text-align:center">OSI七层模型</th><th style="text-align:center">TCP/IP 概念层模型</th><th style="text-align:center">功能</th><th style="text-align:center">TCP/IP 协议族</th></tr></thead><tbody><tr><td style="text-align:center">应用层</td><td style="text-align:center"></td><td style="text-align:center">文件传输，电子邮件，文件服务，虚拟终端</td><td style="text-align:center">TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet</td></tr><tr><td style="text-align:center">表示层</td><td style="text-align:center">应用层</td><td style="text-align:center">数据格式化，代码转换，数据加密</td><td style="text-align:center">没有协议</td></tr><tr><td style="text-align:center">会话层</td><td style="text-align:center"></td><td style="text-align:center">解除或建立与其他接点的联系</td><td style="text-align:center">没有协议</td></tr><tr><td style="text-align:center">传输层</td><td style="text-align:center">传输层</td><td style="text-align:center">提供端对端的接口</td><td style="text-align:center">TCP，UDP</td></tr><tr><td style="text-align:center">网络层</td><td style="text-align:center">网络层</td><td style="text-align:center">为数据报选择路由</td><td style="text-align:center">IP，ICMP，RIP，OSPF，BGP，IGMP</td></tr><tr><td style="text-align:center">数据链路层</td><td style="text-align:center">链路层</td><td style="text-align:center">传输有地址的帧以及错误检测功能</td><td style="text-align:center">SLIP，CSLIP，PPP，ARP，RARP，MTU</td></tr><tr><td style="text-align:center">物理层</td><td style="text-align:center"></td><td style="text-align:center">以二进制数据形式在物理媒体上传输数据</td><td style="text-align:center">ISO2110，IEEE802，IEEE802.2</td></tr></tbody></table><h4 id="2）数据包">2）数据包</h4><p>包、帧、数据包、段、消息</p><ul><li>包是全能术语</li><li>帧用于表示数据链路层中包的单位</li><li>数据报是IP 和UDP 等网络层以上的分层中包的单位</li><li>段则是表示TCP 数据流中的信息</li><li>消息是指应用协议中数据的单位</li></ul><p>每个分层中，都会对所发送的数据添加一个首部，在这个首部中包含了该层必要的信息，如发送的不标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。</p><p><strong>数据包首部</strong></p><p>网络中传输的数据包由首部和上一层传过来的数据组成，首部的结构由协议的具体规范详细定义。在数据包的首部明确标明了协议应该如何读取数据。</p><h4 id="3）数据处理流程">3）数据处理流程</h4><ol><li>应用程序处理<ul><li>首先应用程序会进行编码处理，这些编码相当于OSI 的表示层功能</li><li>编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于OSI 的会话层功能</li></ul></li><li>TCP 模块的处理<ul><li>TCP根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个TCP 首部。</li></ul></li><li>IP 模块的处理<ul><li>IP 将TCP传过来的TCP 首部和TCP 数据合起来当做自己的数据，并在TCP 首部加上自己的IP 首部。IP 包生成后，参考路由控制表决定接受此IP 包的路由或主机。</li></ul></li><li>网络接口（以太网驱动）的处理<ul><li>从IP 传过来的IP 包对于以太网来说是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层发送给接收端。</li></ul></li><li>网络接口（以太网驱动）的处理<ul><li>主机收到以太网包后，首先从以太网包首部找到MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。</li><li>如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如IP、ARP等。</li></ul></li><li>IP 模块的处理<ul><li>IP 模块接收到数据后也做类似的处理。从包首部中判断此IP 地址是否和自己的IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如TCP、UDP。</li><li>对于有路由器的情况，接收端地址往往不是自己的地址，此时需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。</li></ul></li><li>TCP 模块的处理<ul><li>在TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给端口号识别的应用程序。</li></ul></li><li>应用程序的处理<ul><li>接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示响应的内容。</li></ul></li></ol><hr><h3 id="8-IP-详解">8. IP 详解</h3><ul><li>网络层的主要作用是“实现终端节点之间的通信”，这种终端及诶按之间的通信也叫“点对点通信”。</li><li>网络层的下一层——数据链路层的主要作用的在互连同一种数据链路之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端接点之间的数据包传输。</li><li>IP 大致分为三大作用模块，它们是IP 寻址、路由（最终节点为止的转发）以及IP 分包与组包。</li></ul><h4 id="1）IP-地址">1）IP 地址</h4><h5 id="IP地址概述">IP地址概述</h5><ul><li>在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。在数据链路中的 MAC 地址正是用来标识同一个链路中不同计算机的一种识别码。</li><li>作为网络层的 IP ,也有这种地址信息，一般叫做 IP 地址。IP 地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址”。因此，在 TCP/IP 通信中所有主机或路由器必须设定自己的 IP 地址。</li><li>不论一台主机与哪种数据链路连接，其 IP 地址的形式都保持不变。</li><li>IP 地址（IPv4 地址）由32位正整数来表示。IP 地址在计算机内部以二进制方式被处理。然而，由于我们并不习惯于采用二进制方式，我们将32位的 IP 地址以每8位为一组，分成4组，每组以 “.” 隔开，再将每组数转换成十进制数</li></ul><h5 id="IP-地址由网络和主机两部分标识组成">IP 地址由网络和主机两部分标识组成</h5><p>网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP 地址的“主机标识”则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的 IP 地址都不会相互重叠。即 IP 地址具有了唯一性。</p><h5 id="IP地址的分类">IP地址的分类</h5><ul><li><strong>IP 地址分为四个级别，分别为A类、B类、C类、D类。它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分。</strong></li><li>**A 类 IP 地址是首位以 “0” 开头的地址。**从第 1 位到第 8 位是它的网络标识。用十进制表示的话，0.0.0.0~127.0.0.0 是 A 类的网络地址。A 类地址的后 24 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为16,777,214个。</li><li>**B 类 IP 地址是前两位 “10” 的地址。**从第 1 位到第 16 位是它的网络标识。用十进制表示的话，128.0.0.0~191.255.0.0 是 B 类的网络地址。B 类地址的后 16 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为65,534个。</li><li>**C 类 IP 地址是前三位为 “110” 的地址。**从第 1 位到第 24 位是它的网络标识。用十进制表示的话，192.0.0.0~223.255.255.0 是 C 类的网络地址。C 类地址的后 8 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为254个。</li><li>**D 类 IP 地址是前四位为 “1110” 的地址。**从第 1 位到第 32 位是它的网络标识。用十进制表示的话，224.0.0.0~239.255.255.255 是 D 类的网络地址。D 类地址没有主机标识，常用于多播。</li><li>在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为 0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或 IP 地址不可以获知的情况下才使用。而全部为 1 的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么 C 类地址每个网段最多只能有 254（ 28 - 2 = 254）个主机地址的原因。</li></ul><h5 id="广播地址">广播地址</h5><ul><li>广播地址用于在同一个链路中相互连接的主机之间发送数据包。将 IP 地址中的主机地址部分全部设置为 1，就成了广播地址。</li><li>广播分为本地广播和直接广播两种。在本网络内的广播叫做本地广播；在不同网络之间的广播叫做直接广播。</li></ul><h5 id="IP-多播">IP 多播</h5><ul><li><p>多播用于将包发送给特定组内的所有主机。由于其直接使用 IP 地址，因此也不存在可靠传输。</p></li><li><p>相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包</p></li><li><p>多播使用 D 类地址。因此，如果从首位开始到第 4 位是 “1110”，就可以认为是多播地址。而剩下的 28 位可以成为多播的组编号。</p></li><li><p>此外， 对于多播，所有的主机（路由器以外的主机和终端主机）必须属于 224.0.0.1 的组，所有的路由器必须属于 224.0.0.2 的组。</p></li><li><h5 id="子网掩码">子网掩码</h5></li><li><p>现在一个 IP 地址的网络标识和主机标识已不再受限于该地址的类别，而是由一个叫做“子网掩码”的识别码通过子网网络地址细分出比 A 类、B 类、C 类更小粒度的网络。这种方式实际上就是将原来 A 类、B 类、C 类等分类中的主机地址部分用作子网地址，可以将原网络分为多个物理网络的一种机制。</p></li><li><p>子网掩码用二进制方式表示的话，也是一个 32 位的数字。它对应 IP 地址网络标识部分的位全部为 “1”，对应 IP 地址主机标识的部分则全部为 “0”。由此，一个 IP 地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度。当然，子网掩码必须是 IP 地址的首位开始连续的 “1”。</p></li><li><p>对于子网掩码，目前有两种表示方式。第一种是，将 IP 地址与子网掩码的地址分别用两行来表示。以 172.20.100.52 的前 26 位是网络地址的情况为例，如下</p></li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3A5LnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2ZlYmQ2Y2NlNjY3NjQ1MmJiMzk4MWZjY2EyNDM4NTA0?x-oss-process=image/format,png" alt="太厉害了，终于有人能把TCP/IP 协议讲的明明白白了"></p><ul><li>第二种表示方式是，在每个 IP 地址后面追加网络地址的位数用 “/ ” 隔开，如下：</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AxLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2VlMDQwNzU3OTQyMDRkNTI4NmYyODBhZmFmOGNkYzJl?x-oss-process=image/format,png" alt="img"></p><h4 id="2）路由">2）路由</h4><ul><li>发送数据包时所使用的地址是网络层的地址，即 IP 地址。然而仅仅有 IP 地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于“指明路由器或主机”的信息，以便真正发往目标地址。保存这种信息的就是路由控制表。</li><li>该路由控制表的形成方式有两种：一种是管理员手动设置，另一种是路由器与其他路由器相互交换信息时自动刷新。前者也叫做静态路由控制，而后者叫做动态路由控制。</li><li>IP 协议始终认为路由表是正确的。然后，IP 本身并没有定义制作路由控制表的协议。即 IP 没有制作路由控制表的机制。该表示由一个叫做“路由协议”的协议制作而成。</li></ul><h5 id="IP-地址与路由控制">IP 地址与路由控制</h5><ul><li>IP 地址的网络地址部分用于进行路由控制。</li><li>路由控制表中记录着网络地址与下一步应该发送至路由器的地址。</li><li>在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址。</li></ul><h5 id="IP-分包与组包">IP 分包与组包</h5><ul><li>每种数据链路的最大传输单元（MTU）都不尽相同，因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同。</li><li>任何一台主机都有必要对 IP 分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。</li><li>经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。</li></ul><h5 id="路径MTU-发现">路径MTU 发现</h5><ul><li>分片机制也有它的不足。如路由器的处理负荷加重之类。因此，只要允许，是不希望由路由器进行 IP 数据包的分片处理的。</li><li>为了应对分片机制的不足，“路径 MTU 发现” 技术应运而生。路径 MTU 指的是，从发送端主机到接收端主机之间不需要分片是最大 MTU 的大小。即路径中存在的所有数据链路中最小的 MTU 。</li><li>进行路径 MTU 发现，就可以避免在中途的路由器上进行分片处理，也可以在 TCP 中发送更大的包。</li></ul><hr><h3 id="9-UDP-TCP-详解">9. UDP/TCP 详解</h3><ul><li>TCP是面向连接的、可靠的流协议。流就是不间断的数据结构，当应用程序采用TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流量控制”、“拥塞控制”、提高网络利用率等众多功能。</li><li>UDP 是不具有可靠性的数据报协议。细微的处理会交给它上层的应用去完成。在UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此有时会根据自己的需要进行重发处理。</li><li>TCP 用于在传输层有必要实现可靠传输的情况；UDP主要用于那些对高速传输和实时性有较高要求的通信或广播通信。</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA2eThtTjZseTFnOGQydGpzMm93ajMwbDUwZDNkamkuanBn?x-oss-process=image/format,png" alt="image-20191027212512703"></p><h4 id="1）端口号">1）端口号</h4><p>数据链路和IP 中的地址，分别指的是MAC 地址和IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别TCP/IP 网络中互联的主机和路由器。在传输层也有类似于地址的概念，就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。</p><p><strong>端口号的确定</strong></p><ul><li>标准既定的端口号：这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。例如 HTTP、FTP、TELNET 等广为使用的应用协议中所使用的端口号就是固定的。这些端口号被称为知名端口号，分布在 0~1023 之间；除知名端口号之外，还有一些端口号被正式注册，它们分布在 1024~49151 之间，不过这些端口号可用于任何通信用途。</li><li>时序分配法：服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配。动态分配的端口号范围在 49152~65535 之间。</li></ul><p><strong>端口号与协议</strong></p><ul><li>端口号由其使用的传输层协议决定。因此，不同的传输层协议可以使用相同的端口号。</li><li>此外，那些知名端口号与传输层协议并无关系。只要端口一致都将分配同一种应用程序进行处理。</li></ul><h4 id="2）UDP">2）UDP</h4><ul><li>UDP 不提供复杂的控制机制，利用IP 提供面向无连接的通信服务。</li><li>它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。</li><li>此外，传输途中出现丢包，UDP也不负责重发。</li><li>甚至当包的到达顺序出现乱序时也没有纠正的功能。</li><li>如果需要以上的细节控制，不得不交由采用UDP 的应用程序去处理。</li><li>UDP 常用于以下几个方面：<ul><li>包总量较少的通信（DNS、SNMP等）；</li><li>视频、音频等多媒体通信（即时通信）；</li><li>限定于LAN等特定网络中的应用通信；</li><li>广播通信（广播、多播）。</li></ul></li></ul><h4 id="3）TCP">3）TCP</h4><ul><li>TCP 充分地实现了数据传输时的各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</li><li>此外，TCP 作为一种面向连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</li><li>根据TCP 的这些机制，在IP 这种无连接的网络上也能够实现高可靠性的通信（主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）。</li></ul><h5 id="三次握手"><strong>三次握手</strong></h5><ul><li>TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。</li><li>所谓三次握手是建立一个TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AxLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2Y4YWMxMWYwZWM4OTQyYzU5Nzk0M2Y3Y2ExY2JjMTUw?x-oss-process=image/format,png" alt="img"></p><ul><li>第一次握手：客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。</li><li>第二次握手：服务器端收到数据包后，由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。</li><li>第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端直接可以开始传输数据了。</li></ul><h5 id="四次挥手"><strong>四次挥手</strong></h5><ul><li>四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。</li><li>由于TCP 连接是全双工的，因此每个方向必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN 来终止这一方向的连接，收到一个FIN 只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP 连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzgxNWE4ZGM3MzFlODRmMGNhMDhlOGIwZTA1NzdiMWU5?x-oss-process=image/format,png" alt="img"></p><ul><li>中断连接端可以是客户端，也可以是服务器端。</li><li>第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。即客户端没有数据要继续发送，但是如果服务器端还有数据没有发送完毕可以继续发送。</li><li>第二次挥手：服务器端收到FIN 后，先发送ack=M+1，告诉客户端收到了请求，但是还没有准备好，请继续等待消息。这时客户端进入FIN_WAIT_2状态，继续等待服务器端的FIN 报文。</li><li>第三次挥手：当服务器端确定数据已经发送完成，则向客户端发送FIN=N报文，告诉客户端数据已经发送完毕，准备好关闭连接了。服务器端进入LAST_ACK状态。</li><li>第四次挥手：客户端收到FIN=N 报文后，知道可以关闭连接了，但是还是要向服务器端发送ack=N+1进行确认，发送后进入TIME_WAIT状态，如果服务器端没收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待2MSL后依然没有收到回复，则证明服务器端已经正常关闭，则服务器端也关闭连接。最终完成四次挥手。</li></ul><p><strong>问题汇总</strong></p><ol><li><p>为什么要三次握手</p><p>为了防止已失效的连接请求报文突然又传送到了服务端，因为产生错误。</p><p>具体解释： “<strong>已失效的连接请求报文段</strong>”产生情况：</p><p>client 发出的第一个连接请求报文段并没有丢失，而是在某个网络节点长时间滞留，因此导致延误到连接释放以后的某个时间才到达 service。如果没有三次握手，那么此时server收到此失效的连接请求报文段，就误认为是 client再次发出的一个新的连接请求，于是向 client 发出确认报文段，同意建立连接，而此时 client 并没有发出建立连接的情况，因此并不会理会服务端的响应，而service将会一直等待client发送数据，因此就会导致这条连接线路白白浪费。</p><p><strong>如果此时变成两次挥手行不行？</strong></p><p>这个时候需要明白全双工与半双工，再进行回答。比如：</p><ul><li>第一次握手： A给B打电话说，你可以听到我说话吗？</li><li>第二次握手： B收到了A的信息，然后对A说： 我可以听得到你说话啊，你能听得到我说话吗？</li><li>第三次握手： A收到了B的信息，然后说可以的，我要给你发信息啦！</li></ul><p><strong>在三次握手之后，A和B都能确定这么一件事： 我说的话，你能听到； 你说的话，我也能听到。</strong> 这样，就可以开始正常通信了，如果是两次，那将无法确定。</p></li><li><p>为什么要四次挥手</p><p>TCP 协议是一种面向连接，可靠，基于字节流的传输层通信协议。TCP 是全双工模式(同一时刻可以同时发送和接收)，这就意味着，当主机1发出 FIN 报文段时，只是表示主机1已结没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回 ACK报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会中断这次TCP连接。</p></li><li><p>为什么要等待 2MSL</p><p><strong>MSL</strong>：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间</p><p>原因如下：</p><ul><li>保证TCP协议的全双工连接能够可靠关闭</li><li>保证这次连接的重复数据从网络中消息</li></ul><p>第一点： 如果主机1直接 关闭，由于IP协议的不可靠性或者其他网络原因，导致主机2没有收到主机1最后回复的 ACK。那么主机2就会在超时之后继续发送 FIN，此时由于主机1已经关闭，就找不到与重发的 FIN 对应的连接。所以，主机1 不是直接进入 关闭，而是TIME_WAIT 状态。当再次收到 FIN 的时候，能够保证对方收到 ACK ，最后正确关闭连接。</p><p>第二点：如果主机1直接 关闭，然后又再向主机 2 发起一个新连接，我们不能保证这个新连接与刚才关闭的连接端口是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但还是有特殊情况出现；假设新连接和已经关闭的老连接端口号是一样的，<strong>如果前一次连接的某些数据仍然滞留在网络中( Lost Duplicate )</strong>，那些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP 协议就认为哪个延迟的数据时属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接要在 TIME_WAIT 状态等待两倍 MSL ，保证本次连接的所有数据都从网络中消失。</p></li></ol><h5 id="通过序列号与确认应答提高可靠性">通过序列号与确认应答提高可靠性</h5><ul><li>在TCP 中，在发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。反之，则数据丢失的可能性很大。</li><li>在一定时间内没有等待到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。</li><li>未收到确认应答并不意味着数据一定丢失。也可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也会导致发送端误以为数据没有到达目的地而重发数据。</li><li>此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源主机只要按照重传机制重发数据即可。</li><li>对于目标主机来说，反复收到相同的数据是不可取的。为了对上层应用提供可靠的传输，目标主机必须放弃重复的数据包。为此我们引入了序列号。</li><li><strong>序列号是按照顺序给发送数据的每一个字节（8位字节）都标上号码的编号。接收端查询接收数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去。通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。</strong></li></ul><h5 id="重发超时的确定">重发超时的确定</h5><ul><li>**重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。**如果超过这个时间仍未收到确认应答，发送端将进行数据重发。最理想的是，找到一个最小时间，它能保证“确认应答一定能在这个时间内返回”。</li><li>TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间及其偏差。将这个往返时间和偏差时间相加，重发超时的时间就是比这个总和要稍大一点的值。</li><li>在 BSD 的 Unix 以及 Windows 系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过，最初其重发超时的默认值一般设置为6秒左右。</li><li>数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。</li><li>此外，<strong>数据也不会被无限、反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。</strong></li></ul><h5 id="以段为单位发送数据">以段为单位发送数据</h5><ul><li>在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们也可以称其为“最大消息长度”（MSS）。最理想的情况是，最大消息长度正好是 IP 中不会被分片处理的最大数据长度。</li><li>TCP 在传送大量数据时，是以 MSS 的大小将数据进行分割发送。进行重发时也是以 MSS 为单位。</li><li>MSS 在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS 选项，告诉对方自己的接口能够适应的 MSS 的大小。然后会在两者之间选择一个较小的值投入使用。</li></ul><h5 id="利用窗口控制提高速度">利用窗口控制提高速度</h5><ul><li>TCP 以1个段为单位，每发送一个段进行一次确认应答的处理。这样的传输方式有一个缺点，就是包的往返时间越长通信性能就越低。</li><li>为解决这个问题，TCP 引入了窗口这个概念。确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送。如下图所示：</li><li><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2Q1YzgxYjYzMGVlMDRmZGFhYTU3NzgyYTI5OWQ2ZTA3?x-oss-process=image/format,png" alt="img"></li><li>窗口大小就是指无需等待确认应答而可以继续发送数据的最大值。上图中窗口大小为4个段。这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能。</li></ul><h5 id="滑动窗口控制">滑动窗口控制</h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3A5LnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2E2M2JkODI1YTQ3MDRiMTA5NTc2NzZkMjM4YjQzNzBl?x-oss-process=image/format,png" alt="img"></p><ul><li>上图中的窗口内的数据即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答。</li><li>在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。</li><li>收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为滑动窗口控制。</li></ul><h5 id="窗口控制中的重发控制">窗口控制中的重发控制</h5><ul><li>确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的，如下图</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AxLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzg2YWRmOGUxNGFmNjRlZTZhZTBkYjFjMGJlODgwMmY3?x-oss-process=image/format,png" alt="img"></p><ul><li>某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答。如下图所示，当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为高速重发控制。</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AxLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2ZlZmE5MzhlZDVkOTQ5YTM5NTVkOTc5OGQ1ZGM2OWVj?x-oss-process=image/format,png" alt="img"></p><hr><h3 id="其他">其他</h3><h4 id="1-IP-over-everything和-everything-over-IP的含义是什么？">1. IP over everything和 everything over IP的含义是什么？</h4><ul><li>IP over everything 指在TCP/IP体系结构下,IP通过网络接口层可以运行在不同的物理网络之上。</li><li>everything over IP指在TCP/IP体系结构下,各种网络应用均是建立在IP基础之上。</li><li>everything=任意通信介质、任意电气特性、任意通信接口、任意CPU、任意主板、任意操作系统、任意应用软件=任意硬件系统+任意软件系统=任意物。</li></ul><h4 id="2-简述因特网标准定制的几个阶段。请指出这每个阶段的主要特点。">2. 简述因特网标准定制的几个阶段。请指出这每个阶段的主要特点。</h4><p>因特网标准制定通常要经过以下四个阶段(RFC 2026)</p><ul><li>因特网草案(Internet Draft).–此阶段还不是RFC文档.</li><li>建议标准(Proposed Standard).-从此阶段开始成为RFC文档.</li><li>草案标准(Draft Standard).</li><li>因特网标准(Internet Standard).</li></ul><h4 id="3-因特网的两大组成部分（边缘部分与核心部分）的特点是什么？它们的工作方式各有什么特点？">3. 因特网的两大组成部分（边缘部分与核心部分）的特点是什么？它们的工作方式各有什么特点？</h4><ul><li>边缘部分:由各主机构成,用户直接进行信息处理和信息共享;低速连入核心网.</li><li>核心部分:由各路由器连网,负责为边缘部分提供高速远程分组交换.</li></ul><h4 id="4-五层协议栈的体系结构自上往下分别是什么？">4. 五层协议栈的体系结构自上往下分别是什么？</h4><ul><li>应用层</li><li>运输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ul><h4 id="5-协议与服务有何区别？有何关系？">5. 协议与服务有何区别？有何关系？</h4><p>关系：在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务，而要实现本层协议，还需要使用下面一层提供服务。<br>协议和服务的概念的区分：<br>1、协议的实现保证了能够向上一层提供服务。本层的服务用户只能看见服务而无法看见下面的协议。下面的协议对上面的服务用户是透明的。<br>2、协议是“水平的”，即协议是控制两个对等实体进行通信的规则。但服务是“垂直的”，即服务是由下层通过层间接口向上层提供的。上层使用所提供的服务必须与下层交换一些命令，这些命令在OSI中称为服务原语。</p><h4 id="6-网络协议的三个要素是什么？各有什么含义？">6. 网络协议的三个要素是什么？各有什么含义？</h4><p>网络协议：为进行网络中的数据交换而建立的规则、标准或约定。由以下三个要素组成：<br>（1）语法：即数据与控制信息的结构或格式。<br>（2）语义：即需要发出何种控制信息，完成何种动作以及做出何种响应。<br>（3）同步：即事件实现顺序的详细说明。</p><h4 id="7-常见的导引型传输媒体有哪几种？各有什么特点？">7. 常见的导引型传输媒体有哪几种？各有什么特点？</h4><p>1、导引型传输媒体(有线的)有双绞线、 同轴电缆和光纤 ,属于常见的三种传输媒体.</p><p>2、双绞线收螺旋扭在一起的两根绝缘导线组成.线对扭在一起可以减少相互间的辐射电磁干扰,双绞线早就用在电话通信中模拟信号的传输,也可用于数据信号的传输,是最常用的传输媒体.</p><p>3、同轴电缆也象双绞线那样由一对导体组成,但它们的按&quot;同轴&quot;形式构成线对,最里层是内芯,外包一层绝缘材料,外面再一层屏蔽层,最外面则是起保护作用的塑料外套.内芯和屏蔽层构成一对导体.</p><p>4、光纤是光导纤维的简称,它由能传导光波的石英下班纤维,外加保护层构成. 相对于金属来说重量轻、体积(细).用光纤来传输电信号时,在发送端先要将其转换成光信号,而在接收端又要由光检波器瞠原成电信号.</p><h4 id="8-物理层要解决哪些问题？物理层的主要特点是什么？">8. 物理层要解决哪些问题？物理层的主要特点是什么？</h4><p>物理层要解决的主要问题:</p><p>(1)物理层要尽可能地屏蔽掉物理设备和传输媒体,通信手段的不同,使数据链路层感觉不到这些差异,只考虑完成本层的协议和服务.</p><p>(2)给其服务用户(数据链路层)在一条物理的传输媒体上传送和接收比特流(一般为串行按顺序传输的比特流)的能力,为此,物理层应该解决物理连接的建立、维持和释放问题.</p><p>(3)在两个相邻系统之间唯一地标识数据电路.</p><p>物理层的主要特点:</p><p>(1)由于在OSI之前,许多物理规程或协议已经制定出来了,而且在数据通信领域中,这些物理规程已被许多商品化的设备所采用,加之,物理层协议涉及的范围广泛,所以至今没有按OSI的抽象模型制定一套新的物理层协议,而是沿用已存在的物理规程,将物理层确定为描述与传输媒体接口的机械,电气,功能和规程特性.</p><p>(2)由于物理连接的方式很多,传输媒体的种类也很多,因此,具体的物理协议相当复杂.</p><h4 id="9-数据链路层的三个基本问题是什么？为什么必须解决？怎么解决？">9. 数据链路层的三个基本问题是什么？为什么必须解决？怎么解决？</h4><p>三个问题： 封装成帧、透明传输、差错检测</p><p>为什么必须解决：</p><p>⑴封装成帧就是在一段数据前后分别添加首部和尾部。接收端以便从收到的比特流中识别帧的开始与结束，帧定界是分组交换的必然要求；</p><p>⑵ 透明传输避免消息符号与帧定界符号相混淆；</p><p>⑶差错检测防止差错的无效数据帧，浪费网络资源。</p><p>怎么解决：</p><p>（1）封装成帧就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的<a href="http://www.hqpcb.com/quote/">标记</a>，从比特流中识别帧的开始和结束。</p><p>（2）为了解决透明传输问题，字节填充法或字符填充：在控制字符SOH、EOT的前面插入一个转义字符ESC（其十六进制编码是1B，二进制是00011011）。而接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。</p><p>（3）现实的通信链路都不会是理想的。传输过程中，1可能变成0， 0 可能变成1 。这就叫比特差错——误码率。 误码率和信噪比有很大的关系。因此，在计算机网络传输数据时，必须采用各种差错控制技术。目前在数据链路层广泛使用了循环冗余<a href="http://www.hqpcb.com/zhuoluye9">检验</a>（CRC）的检错技术。</p><h4 id="10-IP地址和MAC地址的区别有哪些？为什么要使用这两种不同的地址？">10. IP地址和MAC地址的区别有哪些？为什么要使用这两种不同的地址？</h4><p>IP地址和硬件地址的区别</p><p>1、长度的区别:物理地址即硬件地址,由48bit构成；IP地址由32bit组成,是逻辑地址.</p><p>2、放置位置的区别:IP地址放IP数据报的首部,而硬件地址则放在MAC帧的首部.</p><p>3、使用的区别:在网络层和网络层以上使用IP地址,数据链路层及以下使用硬件地址</p><p>为什么要使用这两种不同的地址</p><p>因为是解决了不同层次的问题</p><h4 id="11-运输层和网络层的通信有什么重要的区别？为什么说运输层是必不可少的？">11. 运输层和网络层的通信有什么重要的区别？为什么说运输层是必不可少的？</h4><p>运输层处于面向通信部分的最高层,同时也是用户功能中的最低层,向它上面的应用层提供服务运输层为应用进程之间提供端到端的逻辑通信,但网络层是为主机之间提供逻辑通信(面向主机,承担路由功能,即主机寻址及有效的分组交换).各种应用进程之间通信需要&quot;可靠或尽力而为&quot;的两类服务质量,必须由运输层以复用和分用的形式加载到网络层.</p><h4 id="12-举例说明有哪些应用程序宁愿使用不可靠的UDP，而不采用可靠的TCP？为什么这样做？">12. 举例说明有哪些应用程序宁愿使用不可靠的UDP，而不采用可靠的TCP？为什么这样做？</h4><p>DP是面向无连接的服务,特点就是,用这种协议传输数据速度快.使用这种协议追求的是传输的即时性而不是传输的质量.在实际应用中比如,qq聊天的语聊,视频,还有网络电话使用的就是UDP协议,还有就是迅雷等一些下载工具用的也是UDP协议.</p><h4 id="13-端口的作用是什么？有哪三种端口号？">13. 端口的作用是什么？有哪三种端口号？</h4><p>(1) 端口的作用是对TCP/IP体系的应用进程进行统一的标志,使运行不同操作系统的计算机的应用进程能够互相通信.</p><p>(2) 三类端口号</p><p>1、熟知端口数值一般为0～1023，标记常规的服务进程;</p><p>2、登记端口号,数值为1024～49151，标记没有熟知端口的非常规的服务进程.</p><p>3、动态和/或私有端口(Dynamicand/orPrivatePorts):从49152到65535.</p><h4 id="14-在停止等待协议中，如果收到两个重复的报文段时，接收方直接丢弃重复的报文段然后什么也不做是否可行？为什么？">14. 在停止等待协议中，如果收到两个重复的报文段时，接收方直接丢弃重复的报文段然后什么也不做是否可行？为什么？</h4><p>(1)不行</p><p>(2)收到重复帧不确认相当于确认丢失,发送方会认为接收方一直没有收到所要发送的TCP报文段,然后会一直重复发送该报文段.</p><h4 id="15-IP数据报中的首部检验和并不检验数据报中的数据。这样做的最大好处是什么？坏处是什么？">15. IP数据报中的首部检验和并不检验数据报中的数据。这样做的最大好处是什么？坏处是什么？</h4><p>在首部中的错误比在数据中的错误更严重，例如，一个坏的地址可能导致分组被投寄到错误的主机。许多主机并不检查投递给他们的分组是否确实是要投递给它们，它们假定网络从来不会把本来是要前往另一主机的分组投递给它们。数据不参与检验和的计算，因为这样做代价大，上层协议通常也做这种检验工作，从前，从而引起重复和多余。因此，这样做可以加快分组的转发，但是数据部分出现差错时不能及早发现。</p>]]></content>
      
      
      <categories>
          
          <category> 期末复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>canvas基础</title>
      <link href="/2021/10/21/canvas%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/10/21/canvas%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="1-Canvas-简介">1. Canvas 简介</h2><p>Canvas是HTML5的一个新标签，属于H5的新特性。简单来说canvas就是一块画布，通常使用JavaScript脚本来绘制图形。Canvas是由HTML代码配合高度和宽度属性而定义出的可绘制区域，JavaScript代码可以访问该区域，类似于其他通用的二维API，通过一套完整的绘图函数来动态生成图形。</p><h2 id="2-Canvas-基本使用">2. Canvas 基本使用</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;tutorial&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;canvas&gt;</code>标签只有两个可选属性，就是width和height。如果不设置这两个属性，那么width默认为300、height为150，单位都是px。也可以使用css属性来设置宽高，但是如果宽高属性和初始比例不一致，就会出现扭曲。</p><p>支持canvas的浏览器会只渲染canvas标签，而忽略其中的内容。不支持canvas的浏览器会直接渲染其中的替代内容。</p><p>canvas会创建一个固定大小的画布，会公开一个或多个<strong>渲染上下文</strong>（画笔），使用<strong>渲染上下文</strong>来绘制和处理需要展示的内容。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;tutorial&#x27;</span>)</span><br><span class="line"><span class="comment">// 获取2d上下文对象</span></span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上述就是获取<strong>渲染上下文</strong>的一段JavaScript代码，其他上下文，比如WebGL使用的基于OpenGL ES的3D上下文不在本文的范围之内。</p><p>代码模板：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Canvas tutorial<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span></span><br><span class="line"><span class="css"><span class="xml">        <span class="selector-tag">canvas</span> &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">            <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span></span></span><br><span class="line"><span class="css"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="css"><span class="xml">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;tutorial&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;tutorial&#x27;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">if</span>(!canvas.getContext) <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//开始代码</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        </span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    draw();</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="3-绘制形状">3. 绘制形状</h2><h3 id="3-1-栅格（grid）和坐标空间">3.1 栅格（grid）和坐标空间</h3><p>如下图所示，<code>canvas</code>元素默认被网格所覆盖。通常来说网格中的一个单元相当于<code>canvas</code>元素中的一像素。栅格的起点为左上角（坐标为（0,0））。所有元素的位置都相对于原点来定位。所以图中蓝色方形左上角的坐标为距离左边（X轴）x像素，距离上边（Y轴）y像素（坐标为（x,y））。</p><p><img src="https://mdn.mozillademos.org/files/224/Canvas_default_grid.png" alt="img"></p><h3 id="3-2-绘制矩形">3.2 绘制矩形</h3><p>canvas只支持一种原生的图形绘制，那就是矩形。所有其他图形都至少需要生成一种路径（path）。</p><p>canvas提供的三种绘制矩形的方法如下：</p><ol><li><code>fillRect(x, y, width, height)</code>绘制一个填充的矩形</li><li><code>strokeRect(x, y, width, height)</code>绘制一个矩形的边框</li><li><code>clearRect(x, y, width, height)</code>清除指定的矩形区域</li></ol><p>这三个方法的参数是相同的，<code>x, y</code>就是矩形的左上角坐标（相对于canvas的坐标原点）。width，和height分别是绘制矩形的宽和高。</p><h2 id="4-绘制路径">4. 绘制路径</h2><p>图形的基本元素是路径，路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。使用路径绘制图形的步骤：</p><blockquote>    1. 创建路径起始点<br>    2. 调用绘制方法绘制出路径<br>    3. 把路径封闭<br>    4. 一旦路径生成，通过描边或者填充路径区域来渲染图形<br></blockquote><p>需要用到的方法有：</p><blockquote>    1. beginPath() 新建一条路径，路径创建成功后，图形绘制命令被指向路径上<br>    2. moveTo(x, y) 把画笔移动到指定坐标，相当于设置路径起始点<br>    3. closePath() 闭合路径之后，图形绘制命令重新指向上下文<br>    4. stroke() 通过线条绘制图形轮廓<br>    5. fill() 通过填充路径的区域生成实心图像<br></blockquote><h3 id="4-1-绘制三角形">4.1 绘制三角形</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (!canvas.getContext) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">            <span class="comment">//新建路径</span></span><br><span class="line">            ctx.beginPath();</span><br><span class="line">            <span class="comment">//将画笔移动到指定坐标</span></span><br><span class="line">            ctx.moveTo(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">            <span class="comment">//绘制线段</span></span><br><span class="line">            ctx.lineTo(<span class="number">200</span>, <span class="number">50</span>);  </span><br><span class="line">            ctx.lineTo(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">            <span class="comment">//闭合路径（连接起始点与终点）</span></span><br><span class="line">            ctx.closePath();</span><br><span class="line">            <span class="comment">//fill方法填充空白区域，且会在路径未闭合时将其闭合</span></span><br><span class="line">            ctx.fill()</span><br><span class="line">            ctx.stroke(); <span class="comment">//绘制路径。</span></span><br><span class="line">        &#125;</span><br><span class="line">draw();</span><br></pre></td></tr></table></figure><h3 id="4-2-绘制圆弧">4.2 绘制圆弧</h3><p>绘制圆弧的两个方法：</p><blockquote>    1. arc(x, y, r, startAngle, endAngle, anticlockwise) 以（x, y）为圆心，r为半径，从startAngle弧度开始到endAngle弧度结束。anticlosewise是布尔值，true表示逆时针，false表示顺时针。（默认为顺时针）<br>    2. arcTo(x1, y1, x2, y2, radius) 根据给定的控制点和半径画一段圆弧，最后再以直线连接两个点。</blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (!canvas.getContext) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">            ctx.beginPath()</span><br><span class="line">            ctx.arc(<span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI / <span class="number">2</span>, <span class="literal">false</span>)</span><br><span class="line">            ctx.stroke()</span><br><span class="line"></span><br><span class="line">            ctx.beginPath()</span><br><span class="line">            ctx.arc(<span class="number">150</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">0</span>, -<span class="built_in">Math</span>.PI / <span class="number">2</span>, <span class="literal">true</span>)</span><br><span class="line">            ctx.closePath()</span><br><span class="line">            ctx.stroke()</span><br><span class="line"></span><br><span class="line">            ctx.beginPath()</span><br><span class="line">            ctx.arc(<span class="number">50</span>, <span class="number">150</span>, <span class="number">40</span>, -<span class="built_in">Math</span>.PI / <span class="number">2</span>, <span class="built_in">Math</span>.PI / <span class="number">2</span>, <span class="literal">false</span>)</span><br><span class="line">            ctx.fill()</span><br><span class="line"></span><br><span class="line">            ctx.beginPath()</span><br><span class="line">            ctx.arc(<span class="number">150</span>, <span class="number">150</span>, <span class="number">40</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI, <span class="literal">false</span>)</span><br><span class="line">            ctx.fill()</span><br><span class="line">        &#125;</span><br><span class="line">        draw();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!canvas.getContext) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.moveTo(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">        <span class="comment">//参数1、2：控制点1坐标   参数3、4：控制点2坐标  参数4：圆弧半径</span></span><br><span class="line">        ctx.arcTo(<span class="number">200</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">        ctx.lineTo(<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">ctx.closePath()</span><br><span class="line">        ctx.stroke();</span><br><span class="line">    &#125;</span><br><span class="line">    draw();</span><br></pre></td></tr></table></figure><h3 id="4-3-绘制贝塞尔曲线">4.3 绘制贝塞尔曲线</h3><p>什么是贝塞尔曲线？</p><p>贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。</p><p>一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋，我们在绘图工具上看到的钢笔工具就是来做这种矢量曲线的。</p><p>贝塞尔曲线是计算机图形学中相当重要的参数曲线，在一些比较成熟的位图软件中也有贝塞尔曲线工具如PhotoShop等。在Flash4中还没有完整的曲线工具，而在Flash5里面已经提供出贝塞尔曲线工具。</p><p>贝塞尔曲线于1962，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由Paul de Casteljau于1959年运用de Casteljau演算法开发，以稳定数值的方法求出贝兹曲线。</p><h4 id="一次贝塞尔曲线-线性贝塞尔曲线">一次贝塞尔曲线(线性贝塞尔曲线)</h4><p><img src="http://lizhenchao.oss-cn-shenzhen.aliyuncs.com/imgs/17-6-4/40655077.jpg" alt="img"></p><h4 id="二次贝塞尔曲线">二次贝塞尔曲线</h4><p><img src="http://lizhenchao.oss-cn-shenzhen.aliyuncs.com/imgs/17-6-4/94917354.jpg" alt="img"></p><p><img src="http://lizhenchao.oss-cn-shenzhen.aliyuncs.com/imgs/17-6-4/35792129.jpg" alt="img"></p><h4 id="三次贝塞尔曲线">三次贝塞尔曲线</h4><p><img src="http://lizhenchao.oss-cn-shenzhen.aliyuncs.com/imgs/17-6-4/69159470.jpg" alt="img"></p><p><img src="http://lizhenchao.oss-cn-shenzhen.aliyuncs.com/imgs/17-6-4/55999388.jpg" alt="img"></p><p><strong>绘制二次贝塞尔曲线</strong></p><p><code>quadraticCurveTo(cplx, cply, x, y)</code></p><p>控制点坐标P1（cplx, cply）结束点坐标P2（x, y）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;tutorial&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!canvas.getContext) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(<span class="number">10</span>, <span class="number">200</span>); <span class="comment">//起始点</span></span><br><span class="line">    <span class="keyword">var</span> cp1x = <span class="number">40</span>, cp1y = <span class="number">100</span>;  <span class="comment">//控制点</span></span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">200</span>, y = <span class="number">200</span>; <span class="comment">// 结束点</span></span><br><span class="line">    <span class="comment">//绘制二次贝塞尔曲线</span></span><br><span class="line">    ctx.quadraticCurveTo(cp1x, cp1y, x, y);</span><br><span class="line">    ctx.stroke();</span><br><span class="line">    </span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.rect(<span class="number">10</span>, <span class="number">200</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    ctx.rect(cp1x, cp1y, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    ctx.rect(x, y, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    ctx.fill();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">draw();</span><br></pre></td></tr></table></figure><p><strong>绘制三次贝塞尔曲线</strong></p><p><code>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</code></p><p>控制点坐标P1（cp1x, cp1y）控制点坐标P2（cp2x, cp2y）结束点P3（x, y）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;tutorial&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!canvas.getContext) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(<span class="number">40</span>, <span class="number">200</span>); <span class="comment">//起始点</span></span><br><span class="line">    <span class="keyword">var</span> cp1x = <span class="number">20</span>, cp1y = <span class="number">100</span>;  <span class="comment">//控制点1</span></span><br><span class="line">    <span class="keyword">var</span> cp2x = <span class="number">100</span>, cp2y = <span class="number">120</span>;  <span class="comment">//控制点2</span></span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">200</span>, y = <span class="number">200</span>; <span class="comment">// 结束点</span></span><br><span class="line">    <span class="comment">//绘制二次贝塞尔曲线</span></span><br><span class="line">    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);</span><br><span class="line">    ctx.stroke();</span><br><span class="line"></span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.rect(<span class="number">40</span>, <span class="number">200</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    ctx.rect(cp1x, cp1y, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    ctx.rect(cp2x, cp2y, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    ctx.rect(x, y, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    ctx.fill();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">draw();</span><br></pre></td></tr></table></figure><h2 id="5-添加样式和颜色">5. 添加样式和颜色</h2><p>给图形上色需要用到如下两个属性：</p><ul><li>fillStyle = color</li><li>strokeStyle = color</li></ul><blockquote>    1. color可以是表示css颜色值的字符串、渐变图案或者图案对象。<br>    2. 默认情况下，线条和填充颜色都是黑色。<br>    3. 一旦设置了fillStyle和strokeStyle的值，那么这个值就会成为新的默认值。</blockquote><p><strong>Transparency（透明度）</strong></p><p><code>globalAlpha = transparencyValue</code></p><p>这个属性影响到canvas里的所有图形的透明度，有效值的范围是0（完全透明）到1.0（完全不透明），默认是1.0。</p><p><strong>lineWidth（线宽）</strong></p><p>只能是正值，默认为1.0。以起始点和终点连线为中心，上下各占线宽的一半。</p><p><strong>lineCap（线条末端样式）</strong></p><p>共有三个值：</p><ul><li>butt：线段末端以方形结束</li><li>round：线段末端以圆形结束</li><li>square：线段末端以方形结束，但是增加一个宽度和线段相同，高度是线段宽度一半的矩形区域。</li></ul><p><strong>lineJoin（同一Path内线条结合处样式）</strong></p><p>共有三个值：</p><ul><li><p>round：圆角连接</p></li><li><p>bevel：平角连接</p></li><li><p>miter（默认）：直接延伸，交于一点</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;tutorial&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!canvas.getContext) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> lineJoin = [<span class="string">&#x27;round&#x27;</span>, <span class="string">&#x27;bevel&#x27;</span>, <span class="string">&#x27;miter&#x27;</span>];</span><br><span class="line">    ctx.lineWidth = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lineJoin.length; i++)&#123;</span><br><span class="line">        ctx.lineJoin = lineJoin[i];</span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.moveTo(<span class="number">50</span>, <span class="number">50</span> + i * <span class="number">50</span>);</span><br><span class="line">        ctx.lineTo(<span class="number">100</span>, <span class="number">100</span> + i * <span class="number">50</span>);</span><br><span class="line">        ctx.lineTo(<span class="number">150</span>, <span class="number">50</span> + i * <span class="number">50</span>);</span><br><span class="line">        ctx.lineTo(<span class="number">200</span>, <span class="number">100</span> + i * <span class="number">50</span>);</span><br><span class="line">        ctx.lineTo(<span class="number">250</span>, <span class="number">50</span> + i * <span class="number">50</span>);</span><br><span class="line">        ctx.stroke();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">draw();</span><br></pre></td></tr></table></figure></li></ul><p><strong>虚线</strong></p><p>用 <code>setLineDash</code> 方法和 <code>lineDashOffset</code> 属性来制定虚线样式. <code>setLineDash</code> 方法接受一个数组，来指定线段与间隙的交替；<code>lineDashOffset</code>属性设置起始偏移量。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;tutorial&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!canvas.getContext) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    ctx.setLineDash([<span class="number">20</span>, <span class="number">5</span>]);  <span class="comment">// [实线长度, 间隙长度]</span></span><br><span class="line">    ctx.lineDashOffset = -<span class="number">0</span>;</span><br><span class="line">    ctx.strokeRect(<span class="number">50</span>, <span class="number">50</span>, <span class="number">210</span>, <span class="number">210</span>);</span><br><span class="line">&#125;</span><br><span class="line">draw();</span><br></pre></td></tr></table></figure><h2 id="6-绘制文本">6. 绘制文本</h2><h3 id="6-1-绘制文本的两个方法">6.1 绘制文本的两个方法</h3><p>canvas提供了两种方法渲染文本：</p><ol><li><code>fillText(text, x, y, [maxWidth])</code>在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的</li><li><code>strokeText(text, x, y, [maxWidth])</code>在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的</li></ol><h3 id="6-2-给文本添加样式">6.2 给文本添加样式</h3><ol><li><code>font = value</code> 用法和css font属性相同，默认字体是<code>10 px sans-serif</code>。</li><li><code>textAlign = value</code>文本对齐选项，可选值包括<code>start, end, left, right 和 center</code>，默认值为<code>start</code>。</li><li><code>textBaseline = value</code>基线对齐选项，可选的值包括：<code>top</code>, <code>hanging</code>, <code>middle</code>, <code>alphabetic</code>, <code>ideographic</code>, <code>bottom</code>。默认值为 <code>alphabetic</code>。</li><li><code>direction = value</code>文本方向。可能的值包括：<code>ltr</code>, <code>rtl</code>, <code>inherit</code>。默认值为<code>inherit</code>。</li></ol><h2 id="7-状态的保存和恢复">7. 状态的保存和恢复</h2><p>此处相当于存在一个状态栈的概念，每次调用save()方法就把当前状态入栈，调用restore()方法时将上一个保存的状态出栈。这里的状态包括以下几种：</p><ul><li>当前应用的变形（即移动，旋转和缩放）</li><li>strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation 的值</li><li>当前的裁切路径（<code>clipping path</code>）</li></ul><h2 id="8-变形">8. 变形</h2><h3 id="8-1-translate-x-y">8.1 translate(x, y)</h3><p>用来移动canvas的原点到指定的位置，translate方法接受两个参数，水平偏移量x 和垂直偏移量y。</p><p>在做变形之前先保存状态是一个良好的习惯。大多数情况下，调用 <code>restore</code> 方法比手动恢复原先的状态要简单得多。又如果你是在一个循环中做位移但没有保存和恢复<code>canvas</code> 的状态，很可能到最后会发现怎么有些东西不见了，那是因为它很可能已经超出 <code>canvas</code> 范围以外了</p><p><strong>一定要注意translate移动的是canvas的坐标原点。</strong></p><h3 id="8-2-rotate-angle">8.2 rotate(angle)</h3><p>旋转坐标轴，这个方法只接受一个参数，旋转的角度angle，它是顺时针方向旋转的，以弧度为单位的值，旋转的中心是坐标原点。</p><h3 id="8-3-scale-x-y">8.3 scale(x, y)</h3><p>这个函数可以用来增减图形在canvas中的像素数目，对形状、位图进行缩小或者放大。scale方法的两个参数分别是横轴和纵轴的缩放因子，它们必须是正值。值比1.0小表示缩小，比1.0大表示放大。默认情况下，canvas的1单位就是1个像素</p><h3 id="8-4-transform-a-b-c-d-e-f">8.4 transform(a, b, c, d, e, f)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ctx;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;tutorial1&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!canvas.getContext) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">    ctx.transform(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">draw();</span><br></pre></td></tr></table></figure><h2 id="9-合成">9. 合成</h2><p><strong>globalCompositeOperation</strong> 属性可以解决两个图形重叠时的行为。</p><p><code>globalCompositeOperation = type</code>,type的值可以是以下13中字符串值之一：</p><ol><li><code>soure-over(default)</code>默认设置，新图像会覆盖在原有图像之上。</li><li><code>source-in</code>仅显示新图像与原有图像的重叠部分。</li><li><code>source-out</code>仅显示新图像与原有图像未重叠部分。</li><li><code>source-atop</code>显示原有图像及新图像与其重叠部分。</li><li><code>destination-over</code>新图像显示于原有图像下方。</li><li><code>destination-in</code>仅显示原有图像与新图像的重叠部分。</li><li><code>destination-out</code>仅显示原有图像与新图像未重叠部分。</li><li><code>destination-atop</code>显示新图像及原有图像与其重叠部分。</li><li><code>lighter</code>对重叠区域的颜色做加处理。</li><li><code>darken</code>保留重叠部分最黑的像素。（每个颜色位进行比较，得到最小的）</li><li><code>lighten</code>保留重叠部分最亮的像素。（每个颜色位进行比较，得到最大的）</li><li><code>xor</code>重叠部分被清除。</li><li><code>copy</code>新图像被保留，其余全部清除。</li></ol><h2 id="10-剪裁路径">10. 剪裁路径</h2><p><code>clip()</code>方法可以将已经创建的路径转换成剪裁路径。剪裁路径的作用是遮罩，只显示剪裁路径内的区域，以外的区域会被隐藏。</p><p><strong>clip()方法只能遮罩在这个方法调用之后绘制的图像，如果是在调用之前就绘制的图像，就无法实现遮罩。</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ctx;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;tutorial1&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!canvas.getContext) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.arc(<span class="number">20</span>,<span class="number">20</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>);</span><br><span class="line">    ctx.clip();</span><br><span class="line">    </span><br><span class="line">    ctx.fillStyle = <span class="string">&quot;pink&quot;</span>;</span><br><span class="line">    ctx.fillRect(<span class="number">20</span>, <span class="number">20</span>, <span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">draw();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> HTML5 </tag>
            
            <tag> canvas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程编程（一）</title>
      <link href="/2021/10/15/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%80/"/>
      <url>/2021/10/15/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1>第一章 Java多线程技能</h1><h1>前言</h1><p>作为多线程编程的第一章，主要介绍Thread类的核心方法</p><blockquote>线程如何启动<br>如何使线程暂停<br>线程的优先级<br>线程安全相关问题<br></blockquote><h1>一、进程和多线程概述</h1><p><a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B/382503?fr=aladdin">进程</a>是受操作系统管理的基本运行单元。<br><br>程序是指令序列，这些指令可以让CPU完成指定的任务。.java程序经编译后形成.class文件，在Windows中启动一个JVM虚拟机相当于创建了一个进程，在虚拟机中加载class文件并运行，在class文件中通过执行创建新线程的代码来执行具体的任务。测试用代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">        &#125;   <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test1类在重复运行3次后，可以在任务管理器的进程列表中看到创建了3个javaw.exe进程，说明每执行一次main()方法就创建一个进程，其本质就是JVM虚拟机进程。</p><p><a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B/103101?fr=aladdin">线程</a>可以理解为在进程中独立运行的子任务。</p><p>使用多线程有什么优点？可以大幅利用CPU的空闲时间来处理其他任务，使用多线程技术可以在同一时间执行更多不同的任务。</p><p><strong>在什么场景下使用多线程技术？</strong></p><blockquote>1） 阻塞。一旦系统中出现了阻塞现象，则可以根据实际情况来使用多线程技术提高运行效率。<br>2）依赖。业务分为两个执行过程，分别是A和B。当A业务发生阻塞情况时，B业务的执行不依赖与A业务的执行结果，这时可以使用多线程技术来提高运行效率；如果B业务的执行依赖A业务的运行结果，则可以不适用多线程技术，按顺序进行业务的执行。</blockquote><h1>二、使用多线程</h1><p>实现多线程编程主要有两种方式：一种是继承Thread类，另一种是实现Runnable接口。</p><h2 id="1-继承Thread类">1.继承Thread类</h2><p>Thread类的声明结构：<code>public class Thread implements Runnable</code><br>从上面的源代码中可以发现，Thread实现了Runnable接口，它们之间具有多态关系，多态结构的示例代码如下:</p><p><code>Runnable run1 = new Thread();</code></p><p><code>Runnable run2 = new MyThread();</code></p><p><code>Thread t1 = new MyThread();</code></p><p><strong>使用Thread类的方式创建新线程时，最大的局限是不支持多继承，因为Java语言的特点是单根继承，所以为了支持多继承，完全可以实现Runnable接口。</strong></p><p>创建一个自定义的线程类MyThread.java，此类继承自Thread，并且重写run()方法。在run()方法中添加新线程要执行的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mythread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行类代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mythread.MyThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start();<span class="comment">//耗时大</span></span><br><span class="line">        System.out.println(<span class="string">&quot;运行结束！&quot;</span>);<span class="comment">//耗时小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用start()方法启动一个线程，线程启动后会自动调用线程对象中的run()方法，run()方法中的代码就是线程对象要执行的任务，是线程任务的入口。<br>start()方法耗时的原因是执行了多个步骤，具体如下：</p><blockquote>1）通过JVM告诉操作系统创建Thread<br>2）操作系统开辟内存并使用Windows SDK中的creatThread()函数创建Thread线程对象。<br>3）操作系统对Thread对象进行调度，以确定执行时机。<br>4）Thread在操作系统中被成功执行。</blockquote><p>在使用多线程技术时代码的运行结果与代码的执行顺序和调用顺序是无关的。另外，线程是一个子任务，CPU以不确定的方式，或者说是以随机的时间来调用线程中的run()方法。</p><h2 id="2-线程随机性的展现">2.线程随机性的展现</h2><p>创建自定义线程类MyThread.java的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mythread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;run=&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再创建运行类Test.java代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mythread.MyThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.setName(<span class="string">&quot;myThread&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main=&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread.java中的start()方法通知“线程规划器”——此线程已经准备就绪，准备调用线程对象的run()方法。如果调用thread.run()方法，而不是thread.start()方法，其实就不是异步执行了，而是同步进行。<br>多线程随机输出的原因是CPU将时间片分给不同的线程，线程获得时间片后就执行任务。时间片即CPU分配给各个程序的时间。每个线程被分配一个时间片，在当前的时间片内CPU去执行线程中的任务。<strong>CPU在不同的线程进行切换是需要耗时的，所以并不是创建的线程越多，运行效率就越高。</strong></p><h2 id="3-实现Runnable接口">3.实现Runnable接口</h2><p>如果想创建的线程类已经有一个父类了，就不能再继承Thread类，所以需要实现Runnable接口来解决这样的情况。<br>创建一个实现Runnable接口的MyRunnable类，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> myrunnable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;运行中！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行类代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> myrunnable.MyRunnable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-使用Runnable接口实现多线程的优点">4.使用Runnable接口实现多线程的优点</h2><p>首先创建业务A类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a_save_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a中的保存数据方法被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再创建业务B类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BServer</span> <span class="keyword">extends</span> <span class="title">AServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a_save_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;b中的保存数据方法被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">b_save_method();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过实现Runnable接口，可间接地实现“多继承”的效果。在非多继承的情况下，使用继承Thread类和实现Runnable接口两种方式在去的程序运行的结果上没什么太大区别，一旦出现“多继承”的情况，则采用实现Runnable接口的方式来处理多线程问题是很必要的。</p><h2 id="5-实例变量共享造成的非线程安全问题与解决方案">5.实例变量共享造成的非线程安全问题与解决方案</h2><p>自定义线程类中的实例变量针对其他线程可以有共享和不共享之分，在多个线程之间交互时是很重要的技术点。</p><h3 id="不共享数据的情况">不共享数据的情况</h3><p>每个线程都有各自的变量，各自控制自己的变量，变量不共享，不存在多个线程访问同一个变量的问题。</p><h3 id="共享数据的情况">共享数据的情况</h3><p>共享数据的情况就是多个线程可以访问同一个变量，不同线程可能同时对一个变量进行处理，就会产生“非线程安全问题”。可以通过在run()方法前加入<strong>synchronized</strong>关键字，使多个线程在执行run()方法时，以排队的方式进行处理。<strong>synchronized</strong>关键字可以对任意对象及方法加锁，而加锁的代码被称为“互斥区”或“临界区”。<br>当一个线程想要执行同步方法里面的代码时，就会首先尝试申请这把锁，如果申请到这把锁，则执行互斥区代码；若申请不到，就会一直申请这把锁，直到申请到为止，而且多个线程会争抢这把锁。</p><h2 id="6-Servlet技术造成的非线程安全问题与解决方案">6.Servlet技术造成的非线程安全问题与解决方案</h2><p>非线程安全问题主要是指多个线程对同一个对象中的同一个实例变量进行操作时会出现值被更改，值不同步的情况，影响程序执行流程。示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String usernameRef;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String passwordRef;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            usernameRef = username;</span><br><span class="line">            <span class="keyword">if</span> (username.equals(<span class="string">&quot;a&quot;</span>)) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            passwordRef = password;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;username=&quot;</span> + usernameRef + <span class="string">&quot; password=&quot;</span> + password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果1：</span></span><br><span class="line"><span class="comment">b bb</span></span><br><span class="line"><span class="comment">a aa</span></span><br><span class="line"><span class="comment">运行结果2:</span></span><br><span class="line"><span class="comment">a bb</span></span><br><span class="line"><span class="comment">a aa</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>线程ALogin.java代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"><span class="keyword">import</span> controller.LoginServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ALogin</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LoginServlet.doPost(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;aa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程BLogin.java代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> extthread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> controller.LoginServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BLogin</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LoginServlet.doPost(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;bb&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行类Run.java代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> extthread.ALogin;</span><br><span class="line"><span class="keyword">import</span> extthread.BLogin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ALogin a = <span class="keyword">new</span> ALogin();</span><br><span class="line">        a.start();</span><br><span class="line">        BLogin b = <span class="keyword">new</span> BLogin();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决如上“非线程安全”问题同样可以使用<strong>synchronized</strong>关键字，更改代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String usernameRef;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String passwordRef;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            usernameRef = username;</span><br><span class="line">            <span class="keyword">if</span> (username.equals(<span class="string">&quot;a&quot;</span>)) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            passwordRef = password;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;username=&quot;</span> + usernameRef + <span class="string">&quot; password=&quot;</span> + password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">a aa</span></span><br><span class="line"><span class="comment">b bb</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1>currentThread()方法</h1><p><code>currentThread()</code>方法可返回代码段正在被哪个线程调用。<br>创建MyThread类，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mythread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法的打印：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run方法的打印：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行类代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> run;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mythread.MyThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造方法的打印： main</span></span><br><span class="line"><span class="comment">run方法的打印： Thread—0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>MyThread.java类的构造函数是被main线程调用的，而run方法是被Thread-0线程调用的，run()方法是自动调用的方法。<br>更改代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> run;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mythread.MyThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">//myThread.start();</span></span><br><span class="line">        myThread.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造方法的打印： main</span></span><br><span class="line"><span class="comment">run方法的打印： main</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>执行方法run()和start()的区别</p><blockquote>1）my.run();：立即执行run()方法，不启动新的线程。<br>2）my.start();：执行run()的时机不确定，启动新的线程</blockquote><h1>isAlive方法</h1><p><code>isAlive()</code>方法的功能是判断当前的线程是否存活.<br>测试代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mythread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run==&quot;</span> + <span class="keyword">this</span>.isAlive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> run;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mythread.MyThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        System.out.println(<span class="string">&quot;begin==&quot;</span> + myThread.isAlive());</span><br><span class="line">        myThread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;end==&quot;</span> + myThread.isAlive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">begin==false</span></span><br><span class="line"><span class="comment">end==true</span></span><br><span class="line"><span class="comment">run==true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>isAlive()方法的作用是测试线程是否处于活动状态。线程已经启动且尚未终止的状态即活动状态。如果线程处于正在运行或准备开始运行的状态，就认为线程是“存活”的。对于代码：<br>System.out.println(“end==” + myThread.isAlive());<br>虽然其输出的值是true，但此值是不确定的，因为此时myThread线程还未执行完毕，如果将代码更改如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> run;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mythread.MyThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        System.out.println(<span class="string">&quot;begin==&quot;</span> + myThread.isAlive());</span><br><span class="line">        myThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;end==&quot;</span> + myThread.isAlive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=999AAA >则代码System.out.println(“end==” + myThread.isAlive());<br>输出结果为false，因为myThread对象已经在1s之内执行完毕。</p><h1>sleep(long millis)方法</h1><p>sleep方法的使用是在指定的时间（毫秒）内让当前“正在执行的线程”休眠（暂停执行），这个“正在执行的线程”是指this.currentThread()返回的线程。<br>示例代码，类Mythread.java代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mythread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;run threadName=&quot;</span></span><br><span class="line">                    + <span class="keyword">this</span>.currentThread().getName() + <span class="string">&quot; begin=&quot;</span></span><br><span class="line">                    + System.currentTimeMillis());</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;run threadName=&quot;</span></span><br><span class="line">                    + <span class="keyword">this</span>.currentThread().getName() + <span class="string">&quot; end=&quot;</span></span><br><span class="line">                    + System.currentTimeMillis());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行类Run1.java代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> run;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mythread.MyThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        System.out.println(<span class="string">&quot;begin=&quot;</span> + System.currentTimeMillis());</span><br><span class="line">        myThread.run();</span><br><span class="line">        System.out.println(<span class="string">&quot;end=&quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">begin=1604938554575</span></span><br><span class="line"><span class="comment">run threadName=main begin=1604938554582</span></span><br><span class="line"><span class="comment">run threadName=main end=1604938556589</span></span><br><span class="line"><span class="comment">end=1604938556589</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>运行类Run2.java代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> run;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mythread.MyThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        System.out.println(<span class="string">&quot;begin=&quot;</span> + System.currentTimeMillis());</span><br><span class="line">        myThread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;end=&quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">begin=1604938758015</span></span><br><span class="line"><span class="comment">end=1604938758021</span></span><br><span class="line"><span class="comment">run threadName=Thread-0 begin=1604938758021</span></span><br><span class="line"><span class="comment">run threadName=Thread-0 end=1604938760033</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>直接调用run()方法，main线程和MyThread线程同步执行。<br>使用start()方法启动线程，由于main线程与MyThread线程是异步执行的，所以首先输出的信息为begin和end，而MyThread线程是后执行的，在最后两行间隔了2s输出run…begin和run…end相关的信息。</p><h1>sleep(long millis, int nanos)方法</h1><p><code>sleep(long millis, int nanos)</code>方法的作用是在指定的毫秒数加指定的纳秒数内让当前正在运行的线程休眠（停止执行），此操作受到系统计时器和调度程序的精度和准确性的影响。</p><h1>StackTraceElement[] getStackTrace()方法</h1><p><code>StackTraceElement[] getStackTrace()</code>方法的作用是返回一个表示该线程堆栈跟踪元素的数组。如果该线程尚未启动或已经终止，则该方法返回一个零长度数组。如果返回的数组不是零长度的，则其第一个元素代表堆栈顶，它是该数组中最新的方法调用。最后一个元素代表堆栈底，是该数组中最旧的方法调用。</p><h1>static void dumpStack()方法</h1><p><code>static void dumpStack()</code>方法的作用的将当前线程的堆栈跟踪信息输出至标准错误流。该方法仅用于调试。</p><h1>getId()方法</h1><p><code>getId()</code>方法用于取得线程的唯一标识。</p><h1>三、停止线程</h1><p>停止一个线程意味着在线程处理完任务之前停止正在做的操作，也就是放弃当前的操作，必须做好防范措施，以便达到预期的效果。停止一个线程可以使用<code>Thread.stop()</code>方法，但是这个方法是不安全的，而且是被弃用的。<br>大多数情况下，停止一个线程使用Thread.interrupt()方法，但这个方法不会终止一个正在运行的线程，还需要加入一个判断才可以完成线程的停止。<br>在Java中有 3 种方法可以使正在运行的线程终止运行：</p><ol><li>使用退出标志使线程正常退出。</li><li><s>使用stop()方法强制终止线程。</s></li><li>使用interrupt()方法终止线程。</li></ol><h2 id="1-终止不了的线程">1. 终止不了的线程</h2><p>调用interrupt()方法仅仅是在当前线程中做了一个停止的标志，不是真正的停止线程。</p><h2 id="2-判断线程是否为停止状态">2. 判断线程是否为停止状态</h2><p>Thread.java 类提供了两个判断方法：</p><ol><li>public static boolean interrupted(): 测试currentThread() 是否已经中断。</li><li>public boolean this.isInterrupted(): 测试 this 关键字所在类的对象是否已经中断。</li></ol><h1>四、暂停线程</h1><p>暂停线程意味着此线程还可以恢复运行，可以使用suspend()方法暂停线程，使用resume()方法来恢复线程的执行。</p><h2 id="1-suspend-方法与resume-方法的缺点——独占">1. suspend()方法与resume()方法的缺点——独占</h2><p>如果suspend()与resume()方法使用不当，很容易造成公共同步对象被独占，其他线程无法访问公共同步对象的结果。若两个线程的run() 方法都调用了被synchronized 修饰的方法，A线程被暂停，则B线程即使启动也无法进入该方法。</p><h2 id="2-suspend-方法与resume-方法的缺点——数据不完整">2. suspend()方法与resume()方法的缺点——数据不完整</h2><p>线程暂停可能会导致数据不完整的情况，想要实现对线程的暂停与恢复处理，可使用wait()、notify()或notifyAll() 方法。</p><h1>四、yield()方法</h1><p>yield() 方法的作用是放弃当前的CPU资源，让其他任务去占用CPU执行时间，放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片。</p><h1>五、线程的优先级</h1><p>在操作系统中，线程可以划分优先级，优先级较高的线程得到的CPU资源较多，也就是CPU优先执行优先级较高的线程对象中的任务，其实就是让高优先级的线程获得更多的CPU时间片。<br>设置线程优先级有助于“线程规划器”确定下一次选择哪一个线程来优先执行。设置线程优先级使用setPriority()方法。<br>在Java中，线程的优先级分为1~10共10个等级，如果优先级小于1或大于10，JDK会抛出异常 <code>throw new IllegalArgumentException()</code></p><h2 id="1-线程优先级的继承特性">1. 线程优先级的继承特性</h2><p>在Java中，线程的优先级具有继承性，例如A 线程启动B 线程，则B 线程的优先级与A 线程是一样的。</p><h2 id="2-优先级的规律性">2. 优先级的规律性</h2><p>当线程优先级的等级差距很大时，谁先被执行完和代码调用顺序无关。</p><h2 id="3-优先级的随机性">3. 优先级的随机性</h2><p>优先级高的线程并不一定每一次都先执行完run()方法中的任务，也就是线程优先级与输出顺序无关，这两者没有依赖关系，它们具有不确定性和随机性。</p><h2 id="4-优先级对线程运行速度的影响">4. 优先级对线程运行速度的影响</h2><p>优先级高的运行速度快。</p><h1>六、 守护线程</h1><p>Java中有两种线程，一种是用户线程，也称非守护线程；另一种是守护线程。<br>守护线程是一种特殊的线程，当进程中不存在非守护线程了，则守护线程自动销毁。典型的守护线程是垃圾回收线程，当进程中没有非守护线程了，则垃圾回收线程也没有存在的必要了，自动销毁。凡是调用setDaemon(true)代码并传入true 值的线程才是守护线程。要在start() 方法之前执行方法，否则会出现异常。</p><p>文章摘自《Java多线程编程核心技术》高洪岩 著</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>九宫重排问题</title>
      <link href="/2021/10/15/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/10/15/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="数据结构声明">数据结构声明</h2><p>结构体 node_t 封装移动数据 其中 data为当前序列或称当前状态 step_p 为上一步位置</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  step_p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>阶乘表 用于康托展开时的计算</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> fac[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">24</span>,<span class="number">120</span>,<span class="number">720</span>,<span class="number">5040</span>,<span class="number">40320</span>,<span class="number">362880</span> &#125;;</span><br></pre></td></tr></table></figure><p>结构体数组 用于存放移动数据</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> <span class="title">save_step</span>[363880];</span> </span><br></pre></td></tr></table></figure><p>定义了四种移动方法</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> move[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><h2 id="1、康托展开判重">1、康托展开判重</h2><h3 id="1-康托展开定义">1. 康托展开定义</h3><p><img src="https://private.codecogs.com/gif.latex?X%3Dan*%28n-1%29%21+an-1*%28n-2%29%21+...+ai*%28i-1%29%21+...+a2*1%21+a1*0%21" alt="X=an*(n-1)!+an-1*(n-2)!+...+ai*(i-1)!+...+a21!+a10!"></p><p>康托展开用于判断该数列在其全排列下的次序</p><p>九宫最多有 9！即 362880 种排列</p><h3 id="2-康托展开的应用">2. 康托展开的应用</h3><p>此处为康托展开的实现 返回值<code>num</code> 就是当前序列在全排列中的次序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kangtuozhankai</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> s[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, temp, num;</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (s[j] &lt; s[i])  <span class="comment">//判断几个数小于它</span></span><br><span class="line">                temp++;</span><br><span class="line">        num += fac[n - i - <span class="number">1</span>] * temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、BFS-算法（核心）">2、BFS 算法（核心）</h2><p>BFS（breadth-first search），属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。</p><p>算法的具体实现就是如下代码中的两重循环，从返回值可以看出这是一个递归函数，返回值就是移动步数，即递归深度。</p><p>先看内部循环做了哪些工作：</p><p>​共执行了四次循环，每次循环对应上、下、左和右四种移动，对移动的结果进行了处理。具体做法是调用的下文中提到的中间函数，该中间函数会返回一个整数，返回 0 表示此次移动非法（交换位置越界），返回 1 表示普通移动，返回 2 表示找到终点。</p><p><strong>重点理解start，end， next_end 的含义</strong></p><p>要理解这三个变量的含义，不妨从它们的变化入手，在算法开始前，全局变量 start 和 end 都被初始化为 0，算法开始时将 end 的值赋给 next_end，在循环中的每一次合法移动都将结果存入数组 <code>save_step[++next_end].data</code>，并把上一步的位置 start 赋值给 <code>save_step[++next_end].step_p</code>构造结果链，在算法最后，将 start 赋值为 end+1，end 赋值为 next_end。那么这些步骤完成了什么样的工作，或者说有什么作用呢？</p><p>我们知道，在 BFS 算法中需要使用栈来存放每一次的结果，而我们的代码中好像并没有使用栈这种数据结构。所以上述的步骤就是完成了这样的工作，start 可看做每次算法的栈顶，而 end 则是栈底。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> next_end = end;           <span class="comment">//存放下次bfs的end标志位</span></span><br><span class="line">    <span class="keyword">int</span> err, i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> temp[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; start &lt;= end; start++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(temp, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)save_step[start].data, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">            err = zero(i, temp);     <span class="comment">//处理数据里的0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (err)   <span class="comment">//保存数据</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)save_step[++next_end].data, temp, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">                save_step[next_end].step_p = start;     <span class="comment">//记录上次步数位置.      </span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (err == <span class="number">2</span>)  <span class="comment">//找到终点</span></span><br><span class="line">                &#123;</span><br><span class="line">                    end_index = next_end;          <span class="comment">//记录终点步数位置.</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    start = end + <span class="number">1</span>;</span><br><span class="line">    end = next_end;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> + bfs());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、BFS-与康托展开的中间函数">3、BFS 与康托展开的中间函数</h2><p>零（空格）的移动</p><p><strong>重点理解 x，y 的含义</strong></p><p>此处的 x，y 实际上是将一维数组转换为二维表示，横轴为 x，纵轴为 y，可代入具体数据进行验证</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zero</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">unsigned</span> <span class="keyword">char</span> data[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, temp, num;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">        <span class="keyword">if</span> (data[j] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            x = j % <span class="number">3</span> + move[i][<span class="number">0</span>];</span><br><span class="line">            y = j / <span class="number">3</span> + move[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*判断交换位置是否越界*/</span></span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x&gt;<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (y &lt; <span class="number">0</span> || y&gt;<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*判断交换后的位置是否已被走过*/</span></span><br><span class="line">            data[j] = data[x + y * <span class="number">3</span>];</span><br><span class="line">            data[x + y * <span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">            num = kangtuozhankai(data, <span class="number">9</span>);</span><br><span class="line">            <span class="keyword">if</span> (step[num] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">memcmp</span>(end_p, data, <span class="number">9</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            step[num] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、一些其他的函数">4、一些其他的函数</h2><h3 id="打印结果">打印结果</h3><p>利用 bfs 算法中构造的结果链可以很容易地完成</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> step_num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印步数具体内容\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (; step_num &gt;= <span class="number">0</span>; step_num--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;****第%d步****\n&quot;</span>, step_num);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, save_step[end_index].data[i * <span class="number">3</span>],</span><br><span class="line">                save_step[end_index].data[i * <span class="number">3</span> + <span class="number">1</span>],</span><br><span class="line">                save_step[end_index].data[i * <span class="number">3</span> + <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        end_index = save_step[end_index].step_p;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断无解">判断无解</h3><p>在上面已经讨论过 bfs 是一种盲目搜寻法，找到结果的方式就是对整张图进行遍历，直至找到结果，那么如果九宫问题本身就是无解，那么花费的时间一定是很多的。针对这个问题如何解决？</p><p>引入对换、排列的奇偶性和逆序数的概念</p><p><strong>在排列中将任意两个元素对调，其余元素不动，这种作出新排列的手续叫做对换。</strong></p><p>已知定理：一个排列中任意两个元素对换，排列改变奇偶性</p><p>推论：奇排列调成标准排列的对换次数为奇数，偶排列调成标准排列的对换次数为偶数</p><p><strong>在一个排列中,如果一对数的前后位置与大小顺序相反,即前面的数大于后面的数,那么它们就称为一个逆序.一个排列中逆序的总数就称为这个排列的逆序数。</strong></p><p><strong>逆序数为偶数的排列称为偶排列；逆序数为奇数的排列称为奇排列.如2431中,21,43,41,31是逆序,逆序数是4,为偶排列。</strong></p><p>那么在我们的代码中，目标序列为 123456780 很显然是一个偶排列，所以可知有解的排列只能是进行偶数次对换的偶排列和奇数次对换的奇排列。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> step[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (step[i] &gt; step[j])</span><br><span class="line">                num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (num % <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> step[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (step[i] == <span class="number">0</span>)</span><br><span class="line">            p = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check1(step) == ((<span class="number">8</span> - p) % <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
